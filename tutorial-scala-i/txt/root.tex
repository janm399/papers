\documentclass[10 pt]{article}
\input{../../common.tex}

\usepackage[OT1]{fontenc}
\usepackage{marvosym}
\newcommand*\eiadfamily{\fontencoding{OT1}\fontfamily{eiad}\selectfont}

\addbibresource{root.bib}

\title{Scala Tutorial I}

\author{Jan Macháček}

\begin{document}

\maketitle
\begin{abstract}
  Scala is a fusion langauge that combines functional and object-oriented programming paradigms in a syntax that is similar to most other \emph{C-like} languages. The ...
\end{abstract}
\bigskip

\section{Syntax crash-course}
Scala's syntax follows the syntax of other C-like languages, though--like Pascal--the type specification follows an identifier. Scala's \pcode{class} behaves exactly like Java's \pcode{class}, and its synax is not wildly different. (See \autoref{code:syntax-class}.)

\begin{lstlisting}[caption={Classes and methods}, label={code:syntax-class}, language=Scala, escapechar=|]
|Class declaration means the same thing as Java; constructor parameters are specified in the block immediately following the class name.|
|Note that the types follow the identifier; instead of |String constructorParam1| Scala uses |constructorParam1: String
class MyClass(constructorParam1: String, constuctorParam2: Int) {
  
  |Methods begin with the keyword |def|, followed by name and parameters. The return type follows similar pattern; |Unit| means |void.
  |The body of the method follows the equals sign.|
  def execute(methodParam1: List[Int]): Unit = {

  }

}

|Constructing instances uses the typical |new| keyword...|
new MyClass("foo", 42)
  |Method invocation is exactly like Java's|
  .execute(List(1, 2, 3))
\end{lstlisting}

Most of this syntax is familiar and unsurprising; the only thing that might feel odd is the square bracket for ``generics'' in \pcode{List[Int]}: in Java, this would be written as \pcode{List<Int>}. This is part of Scala's legacy. A long, long time ago, XML was very exciting; and Scala allows XML literals. These XML literals use the angle brackets. This meant that a different symbol had to be used for type parameters. Because the square bracket is used for type parameters, array indexing is also done using regular parentheses\footnote{I know, it looks like VisualBasic or Fortran (formerly FORTRAN)!}.

Interfaces use the \pcode{trait} keyword in Scala; their usage and features are similar to \pcode{interface} in Java (particularly Java 8 which adds default implementations). It is possible to make anonymous implementations of a \pcode{trait}, as well as to implement it in ordinary \pcode{class}es. (Viz \autoref{code:syntax-trait}.)

\begin{lstlisting}[caption={Traits}, label={code:syntax-trait}, language=Scala, escapechar=|]
|Apart from the |trait| keyword, the syntax is unremarkable|
trait ReportGenerator {
  |Interface methods are public and abstract; they specify parameters and return type|
  def generate(userId: Int): Array[Byte]
}

|A |trait| can be implemented in a |class| using the keyword |extends|. Additional traits to be implemented use the |with| keyword.|
class ReportGeneratorImpl extends ReportGenerator with Cloneable {
  |Instead of the |@Override| annotation Scala uses the |override| keyword.|
  override def generate(userId: Int): Array[Byte] = ...
  override def clone(): AnyRef = ...
}

|It is also possible to make an anonymous implementation of a trait using the |new| keyword.|
new ReportGenerator {
  override def generate(userId: Int): Array[Byte] = ...
}
\end{lstlisting}

It is worth noting that there is no special syntax for \emph{array of X} in Scala. Instead, it uses \pcode{Array} with the specified type parameter. (So, Java's \pcode{byte[]} becomes \pcode{Array[Byte]}, \pcode{User[]} becomes \pcode{Array[User]}, and so on.) Also notice the \pcode{AnyRef} in the implementation of the \pcode{clone()} method--it is equivalent to \pcode{java.lang.Object}.

So far, there are no major surprises: classes and interfaces work just like most other languages, constructor, method, and parameter definition also looks fairly ordinary. The syntax for functions (finally!) uses parameters (each with its type following the \pcode{:} symbol, if needed) followed by fat arrow \pcode{=>}, and the body of the function. Usage is the same as Java 8; and Scala's collections library contains concepts that are fairly similar.

\begin{lstlisting}[caption={Fields \& variables}, label={code:syntax-fun}, language=Scala, escapechar=|]
|Double every |Int| in the list|
List(1, 2, 3, ...).map { (x: Int) => 2 * x }

|Scala can infer the type of |x|, so there's no need to specify it|
List(1, 2, 3, ...).map { x => 2 * x }

|An alternative syntax uses paretheses in place of brackets|
List(1, 2, 3, ...).map(x => 2 * x)

|It is possible to avoid having to declare the parameter |x|, and use |_| instead. Scala compiler replaces the every occurrence of |_| with a fresh parameter declaration.|
List(1, 2, 3, ...).map(2 * _)
\end{lstlisting}

Finally, fields (and variables) use the keywords \pcode{val} and \pcode{var}. The first declares an immutable variable (and a getter if field), the second declares a mutable variable (and a getter and setter if field); see \autoref{code:syntax-fv}.

\begin{lstlisting}[caption={Fields \& variables}, label={code:syntax-fv}, language=Scala, escapechar=|]
|Field definitions have to specify initial value; use |_| for default value.|
class User {
  var id: Long = _
  var name: String = _
  var dob: Date = _
}

val user = new User
\end{lstlisting}

This code is terrible! The default value for reference types (\pcode{AnyRef}s) is \pcode{null}, and variants of \emph{zero} for primitive types. The \pcode{name} and \pcode{dob} fields in the \pcode{user} instance are \pcode{null}, and \pcode{id} is \pcode{0L}. What's worse, the class has setters for these fields, and it's possible to invoke them. The syntax is somewhat nicer--it looks like plain assignment using the \pcode{=} operator, though it is actually invoking a setter--but the semantics of the code in \autoref{code:syntax-fv2} is terrible.

\begin{lstlisting}[caption={Fields \& variables II}, label={code:syntax-fv2}, language=Scala, escapechar=|]
|Field definitions have to specify initial value; use |_| for default value.|
class User {
  var id: Long = _
  var name: String = _
  var dob: Date = _
}

val user = new User
user.id = 5
user.name = "Foo Quux"
user.dob = ...
\end{lstlisting}

While syntactically valid code, it is very confusing. The \pcode{user} variable is declared immutable, yet it is possible to invoke its setters. The equivalent Java code would declare the \pcode{user} variable \pcode{final}, but then still use the setters to mutate it.

\section{Killer features}
The syntax (and its application) so far looks just like Java with less typing. There must be something else that makes it worth leaving the creature comforts of Java. 

\begin{itemize}
  \item everything is an expression
  \item case classes
  \item pattern matching
  \item for comprehensions
  \item implicits
  \item rich type system
\end{itemize}

\subsection{Everything is an expression.} 
In Java, C, and similar langauges, there are statements and expressions. Statements do not have value, they are typicall control-flow constructs. For example, in Java, \pcode{if (a == b) X else Y} cannot be assigned to a variable, because \pcode{if-then-else} is a statement. In Scala, everything yields a value that can be assigned to a variable. 

\subsection{Case classes.} A case class is just like a class in that it is a container for data and methods, but the fields it contains only have getters. (Immutability only goes as far as immutability of the references. Even in Scala, immutability without any additional code is equivalent to using \pcode{final} in Java.) Nevertheless, case classes are fantastically convenient to define data structures. Consider the \pcode{Person} case class defined in \autoref{code:cc1}.

\begin{lstlisting}[caption={Case class \pcode{Person}}, label={code:cc1}, language=Scala, escapechar=|]
case class Person(firstName: String, lastName: String, age: Int)
\end{lstlisting}

This is all it takes to define an immutable structure (with the T\&Cs from above) with the fields \pcode{firstName}, \pcode{lastName}, and \pcode{age}; but also with appropriate \pcode{toString}, \pcode{hashCode}, and \pcode{equals} implementations. These automatically generated implementations delegate to the \pcode{toString}, \pcode{hashCode}, and \pcode{equals} methods of all the fields, in the order in which they are specified.

To create an instance of a case class, do not use the \pcode{new} keyword; instead, write the parameters directly after the case class name, as shown in \autoref{code:cc2}.

\begin{lstlisting}[caption={Using case class \pcode{Person}}, label={code:cc2}, language=Scala, escapechar=|]
|Notice that there is no |new| keyword; the parameter values are applied directly after the case class name.|
val fq = Person("Foo", "Quux", 42)

|To access the fields, use the familiar |.| notation.|
fq.firstName | $\rvert$ |"Foo"

|Invoking the |toString| method prints a reasonable representation of the case class.|
fq.toString | $\rvert$ |"Person(Foo,Quux,42)"

|It is possible to vary the order of the parameters if the parameter names are also specified. This can help readability.|
val fb = Person(lastName = "Baz", firstName = "Foo", age = 50)
fb.toString | $\rvert$ |"Person(Foo,Baz,50)"

|Equality is implemented by delegation to the parameters' |hashCode| and |equals| methods.|
Person("Foo", "Quux", 42) == fq  | $\rvert$ |true|, even though they are \emph{different} instances.|
fq == Person("Foo", "Quux", 42)  | $\rvert$ |true|, even though they are \emph{different} instances.|
\end{lstlisting}

The consciseness of Scala's syntax is beginning to show. It would have been much more cumbersome to implement all this (including correct \pcode{hashCode}, \pcode{equals}, and reasonable \pcode{toString}) in Java. Even with correct implementations, it would not have been possible to use \pcode{==} to test for instance equality. 

\begin{example}[Exercise: Using case classes and functions]
Create a new case class \pcode{Person} file in \pcode{src/main/scala/com.acme} from \autoref{code:cc1}. Then use \pcode{List.fill(N)(Person(...))} and useful methods in \pcode{scala.util.Random} to generate $N$ random \pcode{Person} instances. Assign those to a variable.
\begin{itemize}
  \item find the oldest person in the list. (Hint: use \pcode{map}, \pcode{max}, and \pcode{find} functions on the \pcode{List[Person]}.)
  \item find the 10 youngest people in the list. (Hint: use \pcode{sortBy} or \pcode{sortWith}, followed by \pcode{take}.)
\end{itemize}

\begin{lstlisting}[caption={Pattern matching}, label={code:pmex}, language=Scala, escapechar=|]
...

object PersonMain extends App {
  
  List.fill(100) ...  

}
\end{lstlisting}
\end{example}

Case classes are also called \emph{product} types. The word product refers to the possible number of values that a case class can hold. Take \pcode{case class ABC(a: Boolean, b: Boolean, c: Boolean)}: there are eight possible values: \pcode{ABC(false, false, false)}, ..., \pcode{ABC(true, true, true)}. The value $8$ is the result of \emph{multiplying} the possible values of all parameters. \pcode{Boolean}s have two values; three \pcode{Boolean} values yield $2 \times 2 \times 2$ possible values of the \pcode{ABC} type. Similarly, \pcode{case class IB(i: Int, b: Boolean)} has $4294967295 \times 2$ possible values. 

Imagine, for a moment, that \pcode{Boolean} is not a built-in primitive. It would be defined as \emph{sum} type: \pcode{sealed trait Boolean; case object True extends Boolean; case object False extends Boolean}. The case instances \pcode{True} and \pcode{False} have exactly one value; consequently, the sum type \pcode{Boolean} has $1 + 1$ possible values. Languages like Haskell\cite{haskell}, F\#\cite{fsharp}, and others have convenient syntax for sum types; see \autoref{code:haskell}.

\begin{lstlisting}[caption={Taxonomy as sum type}, label={code:haskell}, language=Haskell, escapechar=@]
@Defines the data type @Boolean@ as a sum of two products, but each product only has one value.@
data Boolean = True   
             | False

@Defines the subscription type as either a ``one-off'' that carries a particular end-date, or a recurring@
@subscription that carries the start date and the billing period.@
data Subscription = OneOff Date 
                  | Recurring Date Period
\end{lstlisting}

Sum types are very useful way to express alternatives that might not have anything in common other than being of the given type, without clumsy \pcode{instanceof} checks with pattern matching.

\subsection{Patten matching.} 
A pattern match is a way to check that a value has the right ``shape'', and to pull out some or all values from that shape. Think of the simplest pattern matching expression as Java's \pcode{switch} statement in \autoref{code:pm1}.

\begin{lstlisting}[caption={Pattern matching}, label={code:pm1}, language=Scala, escapechar=$]
$This is the equivalent of Java's $switch$ statement, with multi-case and a default case.$
Random.nextInt(10) match {
  $Matches values 0..3$
  case 0|1|2|3 =>
  $Matches only value 6$
  case 6 =>
  $Matches all other values$
  case _ =>
}
\end{lstlisting}

It is possible to match on much more complicated structures; such as tuples. A tuple is a collection of a specific length with elements of arbitrary types. For example \pcode{(1, "foo")} is a tuple of 2 elements of types \pcode{Int} and \pcode{String}; \pcode{("foo", "bar", 1.3)} is a tuple of 3 elements of types \pcode{String}, \pcode{String}, and \pcode{Double}. It is possible to pattern match on those, as shown in \autoref{code:pm2}

\begin{lstlisting}[caption={Pattern matching II}, label={code:pm2}, language=Scala, escapechar=|]
import scala.util.Random
(Random.nextString(Random.nextInt(16)), Random.nextInt(100)) match {
  |Matches tuples with any first element, and second element |== 10|.|
  case (s, 10)                          => |The first element is accessible as |s| here.|

  |Matches only the |("Lucky?", 42)| tuple.|
  case ("Lucky?", 42)                   => |None of the elements are accessible here.|

  |Matches any tuple as long as the first element is longer than 5 characters and second element is less than 10.|
  case (x, y) if x.length > 5 && y < 10 => |Both first and second elements are accessible as |x| and |y|.|
  
  |Matches any value|
  case _                                => |None of the elements are accessible here.|
}
\end{lstlisting}

As useful as tuples are for quick ad-hoc structures, the real deal in pattern matching are case classes. Just like matching on a tuple, it is possible to match on case classes and extract their fields as needed. In addition to using the \pcode{match} keyword followed by \pcode{case}s, pattern matching also applies to declarations of variables in \autoref{code:pm3}.

\begin{lstlisting}[caption={Pattern matching III}, label={code:pm3}, language=Scala, escapechar=|]
|Pattern matches on the right-hand side, pulls out the first parameter as |val first: String|.|
val Person(first, _, _) = Person("Foo", "Bar", 99)

|Pattern matches on the right-hand side, comparing the value of the first parameter to be equal to in-scope variable |first|. (Notice the backticks.)|
val Person(`first`, _, _) = Person("Foo", "Bar", 99)

|Because there are no alternatives, if the |val| pattern match fails, it raises an exception.|
val Person(`first`, _, _) = Person("Fooz", "Bar", 99)
\end{lstlisting}

The pattern match that raises an exception if it fails is often convenient to use in tests. Suppose there 

\begin{example}[Exercise: Using case classes and pattern matching]
Build an numerical expression evaluator; the evaluator should support binary operators $+, -, \times, /$ and support arbitrary nesting. It should be able to evaluate, for example $4+3(5/(12-7))$. To make things simpler, it is not necessary to include error reporting (division by zero, for example), and it is not necessary to provide a way to turn a \pcode{String} into an expression.

\begin{lstlisting}[caption={Expression evaluator}, label={code:ee}, language=Scala, escapechar=|]
|The sum type Expr's subtypes define the ``operations'' we support.|
sealed trait Expr
|The different cases need to support our operations and constants.|
case class Plus(left: Expr, right: Expr) extends Expr
...
case class Const(const: Int) extends Expr

|It will be convenient to package our evaluator in its own module.|
object Evaluator {
  
  |Hint: you will need to pattern-match on the different |Expr|s.|
  def eval(expr: Expr): Int = expr match {
    ...
  }

}

object EvaluatorMain extends App {

  val e = Evaluator.eval(Plus(Plus(Const(4), Const(5)), Const(3)))
  println(e) | $\rvert$ \Printer{ }|12

}
\end{lstlisting}
\end{example}

\begin{example}[Exercise: logical expression simplifier]
Build a logical expression simplifier that reduces the number of logical operations to be performed, and can spot tautologies and contraditions. For example, $(a \land b) \lor (a \land b)$ should simplify to just $a \land b$; $(a \lor \lnot{a})$ should simplify to $\top$ (tautology; always true); $(a \lor \lnot{a}) \land (a \oplus a)$ should simplify to $\bot$ (contradiction; always false).

\begin{lstlisting}[caption={Logical expression simplifier}, label={code:ls}, language=Scala, escapechar=|]
|The sum type LExpr defines the different logical expressions we support.|
sealed trait LExpr

|The different cases need to support our operations and constants.|
case class LAnd(left: LExpr, right: LExpr) extends LExpr
case object Contradiction extends LExpr
...
case class Var(named: String) extends LExpr

|Just like the evaluator, package the simplifier in its own module.|
object Simplifier {
    
  |Hint: you will need to pattern-match on the different |LExpr|s.|
  def simplify(expr: LExpr): LExpr = expr match {
    ...
  }

}

object SimplifierMain extends App {

  val se = Simplifier.simplify(
    LAnd(
      LOr(Var("a"), LNot(Var("a"))),
      LXor(Var("a"), Var("a"))
    )
  )
  println(se) | $\rvert$ \Printer{ }|"Contradition"

}
\end{lstlisting}

\end{example}
 
\subsection{Implicits.} Lipsum...

Pimp-my library.


\begin{example}[Exercise: Pimp my library]
Build a DSL that allows the expression evaluator to be written using natural-looking Scala code--though sadly not using the standard \pcode{+, -, *, /} operators, but using our own \pcode{plus, minus, mult, div} instead. The expression \pcode{5 plus 10} should evaluate to \pcode{Plus(Const(5), Const(10))}. The type \pcode{Int} and \pcode{Expr} do not contain the methods \pcode{plus}, ..., \pcode{div}; it will be necessary to implement implicit conversions (use \pcode{implicit class} for convenience) that contains those methods. 

Hints: \begin{itemize}
  \item because the methods \pcode{plus(r: Expr): Expr}, ..., \pcode{div(r: Expr): Expr} would be the same, consider defining them in a trait (\pcode{trait ExprOps} would be a jolly good name!) that is then mixed into the implicit classes, where the trait defines abstract member \pcode{self: Expr}, which is then used as the left-hand side in the \pcode{Expr} data constructors; the right-hand side coming from the parameter of the method.
  \item implementing a class that adds the methods \pcode{plus}, ..., \pcode{div} to \pcode{Int} will allow for code such as \pcode{10 plus Const(5)}, but it will not compile \pcode{10 plus 5}, because there is no function \pcode{plus}, ..., \pcode{div} that takes an \pcode{Int}. The preferred option is to add those over implicit conversion from \pcode{Int} to \pcode{Expr}: \pcode{implicit def intToExpr(i: Int): Expr} is generally frowned-upon because it allows silent and potentially very powerful conversions.
\end{itemize}

\begin{lstlisting}[caption={Expression evaluator}, label={code:eepm}, language=Scala, escapechar=|]
|It will be useful to package the PML conversions in their own module.|
object Expr {
  |Two conversions will be necessary: |Int -> Expr|, |Expr -> RichExpr|.|
  implicit class RichInt ...
  implicit class RichExpr ...

}

object EvaluatorMain extends App {
  import Expr._
  val e = Evaluator.eval((5 plus 10) minus 8)
  println(e)
}
\end{lstlisting}

If you are feeling inventive or perhaps mischievous, pick unicode identifiers for the boring ASCII method names in the DSL. Resurrect APL by using ÷ instead of \pcode{div}!
\end{example}

\paragraph{Type classes.} XXX

\begin{example}[Exercise: Flexible evaluator]
Allow the expression evaluator to operate on any number-like types, not just \pcode{Int}s. Instead of relying on inheritance, forcing all users of the evaluator to evaluate values conforming to some trait (with the number-crunching methods \pcode{+, -, *, /}), use parametric polymorphism and type classes. The \pcode{Const} data constructor will need to take any type instead of \pcode{Int}; \pcode{RichInt} implicit class will need to pimp any type, not just \pcode{Int}; the \pcode{eval} method will also need to be generic, but will need to (implicitly) require a typeclass \pcode{Fractional} for the generic type. (The Scala standard library defines \pcode{Fractional} and \pcode{Integral} type classes, which contain the division operation whereas \pcode{Numeric} typeclass does not. Pick one, the limitation that not all types are fractional or integral. Dotty will unify this!)

Hints: \begin{itemize}
  \item it is not necessary to constrain the type of the \pcode{Const} data constructor; it can be ``forall A.'' \pcode{Const[A]}.
  \item it will be convenient to use the full implicit syntax in the \pcode{eval} method: \pcode{def eval[A](expr: Expr)(implicit N: Fractional[A]): A} instead of \pcode{def eval[A : Fractional](expr: Expr): A}
  \item the type information for the generic type \pcode{A} will be erased, causing compiler warning in the pattern match. It is possible to eliminate the warning by using another type class. Look for \emph{Scala type tags and manifests}.
\end{itemize}

\begin{lstlisting}[caption={Flexible evaluator (with DSL)}, label={code:eepm2}, language=Scala, escapechar=|]
object Expr {

  trait ExprOps {
    def self: Expr
    def plus... |This will need to take generic type |A|.|
    ...
  }

  implicit class RichA... |This will need to take generic type |A|.|
  implicit class RichExpr(val self: Expr) extends ExprOps

}

sealed trait Expr
...
case class Const... |This will need to take generic type |A|.|

object Evaluator {

  |It will be convenient to use the full implicit syntax here|
  def eval[A](expr: Expr)...: A = expr match {
    ...
  }

}

object EvaluatorMain extends App {
  import Expr._
  |The point of application constrains the generic parameter, it is necessary to specify the type |A|. in |eval|.|
  val e = Evaluator.eval[Double]((5.4 plus math.Pi) minus 8.8)
  ...
}
\end{lstlisting}

Extra work: \begin{itemize}
  \item explore and explain the difference in just adding the generic parameter to the \pcode{Const} data constructor (leaving \pcode{sealed trait Expr} intact), or letting \pcode{Expr} become \pcode{sealed trait Expr[A]}.
  \item explain the effects of covariant type parameter in \pcode{sealed trait Expr[+A]}. (Try \pcode{val e: BigDecimal = Evaluator.eval(Const(4))} with invariant \pcode{Expr} and then with covariant \pcode{Expr} to get started.)
\end{itemize}

\end{example}



\subsection{Rich type system.}

\begin{example}[Exercise: Flexible evaluator with errors]

\begin{lstlisting}[caption={Flexible evaluator (with DSL)}, label={code:eepm2}, language=Scala, escapechar=|]
object EvaluatorMain extends App {
  import Expr._
  Evaluator.eval[Double, Option](4 div 0) | $\rvert$ |None|.|
  Evaluator.eval[Double, Id](4 div 0) | $\rvert$ |RuntimeException("Division by zero")|.|
  Evaluator.eval[Double, ({type L[A] = Either[String, A]})#L](4 div 0) | $\rvert$ |Left("Division by zero")|.|
  ...
  Evaluator.eval[Double, ({type L[A] = Either[String, A]})#L](4 div 1) | $\rvert$ |Right(4.0)|.|
}
\end{lstlisting}
\end{example}


\section{The standard library}
The Scala standard library defines many standard structures in case classes. Picking the two most useful ones, \pcode{Option} and \pcode{Either} are defined as case classes. This means that it is possible to pattern match on their values.

\begin{lstlisting}[caption={Pattern matching in stdlib}, label={code:pm4}, language=Scala, escapechar=|]
|These are the definition in the standard library; note that the actual definitions are more complex, but this code expresses the essence.|

Option[A]| has two alternatives: |Some[A]| and |None|. It is used to express one-or-missing values.|
sealed trait Option[A]
case class Some[A](a: A) extends Option[A]
case object None extends Option[Nothing]

Either[L, R]| has also two alternatives: |Left[L]| and |Right[R]|. It is used to express success or failure, with success by convention|
|on the right and failure on the left.|
sealed trait Either[L, R]
case class Right[R](r: R) extends Either[Nothing, R]
case class Left[L](l: L) extends Either[L, Nothing]
\end{lstlisting}

...


\section{Spring Framework}
The Spring Framework is a dependency injection framework; it encourages composition over inheritance, it encourages expressing dependencies as interfaces rather than concrete implementations. The framework takes care of instantiating the components in the correct order; most components (the ones that fall into the \pcode{@Component} sterotype) are \emph{singletons}. This means that it is possible to treat the \pcode{@Component}-annotated components as namespaces rather than containers of state\footnote{In fact if the methods in \pcode{@Component}-annotated classes mutates \& accesses its fields, it will suffer from race conditions.}. The reason why Spring Framework encourages programming to interfaces is to make the software easily testable: there can be separate implementations or mocks for unit and integration tests.

\begin{lstlisting}[caption={Components}, label={code:sf1-java}, language=Java, escapechar=|]
interface ReportGenerator {
    |Generates the PDF report for the given $user$,|
    |returns the byte array representing the PDF contents|
    byte[] generate(final String user);
}

@Component
public class ReportService {
    private final ReportGenerator reportGenerator;

    @Inject
    public ReportService(final ReportGenerator reportGenerator) {
        this.reportGenerator = reportGenerator;
    }

    public void reportAll() {
        for (final String user : Arrays.asList("a", "b", "c")) {
            final byte[] pdf = this.reportGenerator.generate(user);
            |Now you're on your own...|
        }
    }
 }
\end{lstlisting}

For a Spring Framework application to be able to construct the \pcode{ReportService}, it needs to be able to construct exactly one component that implements the \pcode{ReportGenerator} interface.

\begin{lstlisting}[caption={Components}, label={code:sf2-java}, language=Java, escapechar=|]
@Component
public class JasperReportsReportGenerator implements ReportGenerator {
    public byte[] generate(final String user) {
        ...
    }
}
\end{lstlisting}

Without a DI framework, the work of constructing the dependencies would fall on the programmers, yielding code similar to \autoref{code:sf3-java}.

\begin{lstlisting}[caption={Manual DI}, label={code:sf3-java}, language=Java, escapechar=|]
|Typically in |public static void main(String[] args) |or in a test:|

ReportGenerator rg = new JasperReportsReportGenerator();
ReportService rs = new ReportService(rg);
\end{lstlisting}

Constructing the instances of the \pcode{JasperReportsReportGenerator} and \pcode{ReportService} using their constructors isn't a problem per se, but with growing number of dependencies this grows to be tedious.


\section{Zero to hundred}
FizzBuzz is a typical program that follows \emph{Hello, world}, adding iteration and conditions. The Scala version of FizzBuzz is shown in \autoref{code:fb1}--it shows the definition of a function \pcode{def}, followed by name and arguments, and its implementation that follows the \pcode{=} sign. The loop (\pcode{for}) and condition (\pcode{if}, \pcode{else}) keywords are the old friends from other languages. 

\begin{lstlisting}[caption={Fizz Buzz}, label={code:fb1}, language=Scala, escapechar=|]
def fizzBuzz = {
  for (i <- 1 to 100) {
    if (i % 15 == 0) println("FizzBuzz")
    else if (i % 3 == 0) println("Fizz")
    else if (i % 5 == 0) println("Buzz")
    else println(i)
  }
}
\end{lstlisting}

The FizzBuzz from \autoref{code:fb1} isn't particularly re-usable: it simply prints 100 elements to the standard output, nothing else and nothing more. There is no way, for example, to direct the output to a web socket, or to use it to determine how it maps of the value in the \pcode{integer} domain to the ``FizzBuzz domain''. Hmm!--\emph{mapping} and \emph{domain} sound like mathematics; and functional programming is supposed to be somehow more mathematical. And mathematics is jolly wonderful. 

The first step in making the \pcode{fizzBuzz} more mathematical is to make it map an input to exactly one useful output. Right now, its return type now is \pcode{Unit}, which is a bit like \pcode{void} in Java and C; changing its definition to \pcode{def fizzBuzz2(max: Int): Unit} (and then using the \pcode{max} parameter in the loop) isn't particularly useful: it is a mapping from a number to \pcode{Unit}. And, if this were mathematics, there can be only one such mapping: \pcode{def fizzBuzz2(max: Int): Unit = ()}. Instead of printing the elements to the console, the implementation needs to return a value that can be printed. A a simple \pcode{String} would do, but a \pcode{Seq} of \pcode{String}s is better. The type becomes \pcode{Int => Seq[String]}, and the implementation is shown in \autoref{code:fb2}.

\begin{lstlisting}[caption={Fizz Buzz}, label={code:fb2}, language=Scala, escapechar=|]
def fizzBuzz(max: Int): Seq[String] = {
  var result = List.empty[String]
  for (i <- 1 to max) {
    if (i % 15 == 0) result = result :+ "FizzBuzz"
    else if (i % 3 == 0) result = result :+ "Fizz"
    else if (i % 5 == 0) result = result :+ "Buzz"
    else result = result :+ i.toString
  }
  result
}
\end{lstlisting}

This is a huge improvement! The \pcode{fizzBuzz} is now indeed a function: it maps input to output and its result depends only on the value of the parameter. It would even be possible to pre-compute the result for all possible values of the input and replace the function's body with a look-up in that table: the function would become just data! 

Well, the outside looks great, but the implementation stinks! It uses mutation, and what about the strange \pcode{:+} operator in \pcode{result :+ "Fizz"}, never mind the \pcode{for (i <- 1 to max) \{...\}} nonsense!

\begin{lstlisting}[caption={Fizz Buzz}, label={code:fb3}, language=Scala, escapechar=|]
def fizzBuzz(max: Int): Seq[String] = {
  def fb(i: Int): String =
    if (i % 15 == 0) "FizzBuzz"
    else if (i % 3 == 0) "Fizz"
    else if (i % 5 == 0) "Buzz"
    else i.toString

  (1 to max).map(fb)
}
\end{lstlisting}




In Scala, every concrete type (except \pcode{Nothing}) can have a value: for example, the type \pcode{Boolean} is inhabited by values \pcode{true, false}; the type \pcode{Int} is inhabited by values such as \pcode{5, 42, -100, 0, ...}; the type \pcode{String} is inhabited by values such as \pcode{"Hi", ":)", ""}; the type \pcode{Unit} is inhabited by the only value \pcode{()}. (No, really, it's perfectly good Scala syntax to write \pcode{()} as value. It's just not particularly useful.) The only type that does not have any inhabitants is \pcode{Nothing}: it represents expressions that \emph{diverge}, for example throwing an exception.

Taking a more precise look at \pcode{def fizzBuzz} reveals its type to be \pcode{Unit}; it evaluates to only one value, namely \pcode{()}. If it were a function in the sense of strictly mapping input to output, it would be no different from any other \pcode{()} \emph{constant}. But \pcode{fizzBuzz} does some additional work before returning \pcode{()}; this additional work is not represented by its type, even though it is its \emph{raison d'être}. 

In Java and C, there is no \emph{value} of type \pcode{void}

 As it stands, its type is \pcode{() => Unit}, 

\newpage

\section{Pattern matching}
sasd
\newpage

\section{}

\printbibliography

\end{document}
