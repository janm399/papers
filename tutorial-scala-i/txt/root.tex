\documentclass[10 pt]{article}
\input{../../common.tex}

\usepackage[OT1]{fontenc}
\usepackage{marvosym}
\newcommand*\eiadfamily{\fontencoding{OT1}\fontfamily{eiad}\selectfont}

\addbibresource{root.bib}

\title{Scala Tutorial I}

\author{Jan Macháček}

\begin{document}

\maketitle
\begin{abstract}
  Scala is a fusion language that combines functional and object-oriented programming paradigms in a syntax that is similar to most other \emph{C-like} languages. The ...
\end{abstract}
\bigskip

\section{Syntax crash-course}
Scala's syntax follows the syntax of other C-like languages, though--like Pascal--the type specification follows an identifier. Scala's \pcode{class} behaves exactly like Java's \pcode{class}, and its syntax is not wildly different. (See \autoref{code:syntax-class}.)

\begin{lstlisting}[caption={Classes and methods}, label={code:syntax-class}, language=Scala, escapechar=|]
|Class declaration means the same thing as Java; constructor parameters are specified in the block immediately following the class name.|
|Note that the types follow the identifier; instead of |String constructorParam1| Scala uses |constructorParam1: String
class MyClass(constructorParam1: String, constuctorParam2: Int) {
  
  |Methods begin with the keyword |def|, followed by name and parameters. The return type follows similar pattern; |Unit| means |void.
  |The body of the method follows the equals sign.|
  def execute(methodParam1: List[Int]): Unit = {

  }

}

|Constructing instances uses the typical |new| keyword...|
new MyClass("foo", 42)
  |Method invocation is exactly like Java's|
  .execute(List(1, 2, 3))
\end{lstlisting}

Most of this syntax is familiar and unsurprising; the only thing that might feel odd is the square bracket for ``generics'' in \pcode{List[Int]}: in Java, this would be written as \pcode{List<Int>}. This is part of Scala's legacy. A long, long time ago, XML was very exciting; and Scala allows XML literals. These XML literals use the angle brackets. This meant that a different symbol had to be used for type parameters. Because the square bracket is used for type parameters, array indexing is also done using regular parentheses\footnote{I know, it looks like VisualBasic or Fortran (formerly FORTRAN)!}.

Interfaces use the \pcode{trait} keyword in Scala; their usage and features are similar to \pcode{interface} in Java (particularly Java 8 which adds default implementations). It is possible to make anonymous implementations of a \pcode{trait}, as well as to implement it in ordinary \pcode{class}es. (Viz \autoref{code:syntax-trait}.)

\begin{lstlisting}[caption={Traits}, label={code:syntax-trait}, language=Scala, escapechar=|]
|Apart from the |trait| keyword, the syntax is unremarkable|
trait ReportGenerator {
  |Interface methods are public and abstract; they specify parameters and return type|
  def generate(userId: Int): Array[Byte]
}

|A |trait| can be implemented in a |class| using the keyword |extends|. Additional traits to be implemented use the |with| keyword.|
class ReportGeneratorImpl extends ReportGenerator with Cloneable {
  |Instead of the |@Override| annotation Scala uses the |override| keyword.|
  override def generate(userId: Int): Array[Byte] = ...
  override def clone(): AnyRef = ...
}

|It is also possible to make an anonymous implementation of a trait using the |new| keyword.|
new ReportGenerator {
  override def generate(userId: Int): Array[Byte] = ...
}
\end{lstlisting}

It is worth noting that there is no special syntax for \emph{array of X} in Scala. Instead, it uses \pcode{Array} with the specified type parameter. (So, Java's \pcode{byte[]} becomes \pcode{Array[Byte]}, \pcode{User[]} becomes \pcode{Array[User]}, and so on.) Also notice the \pcode{AnyRef} in the implementation of the \pcode{clone()} method--it is equivalent to \pcode{java.lang.Object}.

So far, there are no major surprises: classes and interfaces work just like most other languages, constructor, method, and parameter definition also looks fairly ordinary. The syntax for functions (finally!) uses parameters (each with its type following the \pcode{:} symbol, if needed) followed by fat arrow \pcode{=>}, and the body of the function. Usage is the same as Java 8; and Scala's collections library contains concepts that are fairly similar.

\begin{lstlisting}[caption={Fields \& variables}, label={code:syntax-fun}, language=Scala, escapechar=|]
|Double every |Int| in the list|
List(1, 2, 3, ...).map { (x: Int) => 2 * x }

|Scala can infer the type of |x|, so there's no need to specify it|
List(1, 2, 3, ...).map { x => 2 * x }

|An alternative syntax uses paretheses in place of brackets|
List(1, 2, 3, ...).map(x => 2 * x)

|It is possible to avoid having to declare the parameter |x|, and use |_| instead. Scala compiler replaces the every occurrence of |_| with a fresh parameter declaration.|
List(1, 2, 3, ...).map(2 * _)
\end{lstlisting}

The last form \pcode{2 * _} is somewhat unusual and worth exploring further. The Scala compiler mechanically translates the each underscore in the function body into a parameter (and ``replaces'' the underscore with that parameter); \pcode{2 * _} is translated into \pcode{p_0 => 2 * p_0}. Now, exploring the functions on type \pcode{Int}, the type of the function \pcode{*} is \pcode{Int => Int}. (It is defined as \pcode{def *(that: Int): Int}). The type of \pcode{2 *} is therefore \pcode{Int => Int}, just like the type of \pcode{2 * _}, or \pcode{_ * 2}, or \pcode{x => x * 2}--assuming the parameter can be inferred to be \pcode{Int}. Consequently, it is possible to leave out the underscore in the \pcode{map} function and only write \pcode{List(1, 2, 3, ...).map(2 *)}\footnote{This might be somewhat familiar to Java 8 programmers with method references with the double colons}.

Finally, fields (and variables) use the keywords \pcode{val} and \pcode{var}. The first declares an immutable variable (and a getter if field), the second declares a mutable variable (and a getter and setter if field); see \autoref{code:syntax-fv}.

\begin{lstlisting}[caption={Fields \& variables}, label={code:syntax-fv}, language=Scala, escapechar=|]
|Field definitions have to specify initial value; use |_| for default value.|
class User {
  var id: Long = _
  var name: String = _
  var dob: Date = _
}

val user = new User
\end{lstlisting}

This code is terrible! The default value for reference types (\pcode{AnyRef}s) is \pcode{null}, and variants of \emph{zero} for primitive types. The \pcode{name} and \pcode{dob} fields in the \pcode{user} instance are \pcode{null}, and \pcode{id} is \pcode{0L}. What's worse, the class has setters for these fields, and it's possible to invoke them. The syntax is somewhat nicer--it looks like plain assignment using the \pcode{=} operator, though it is actually invoking a setter--but the semantics of the code in \autoref{code:syntax-fv2} is terrible.

\begin{lstlisting}[caption={Fields \& variables II}, label={code:syntax-fv2}, language=Scala, escapechar=|]
|Field definitions have to specify initial value; use |_| for default value.|
class User {
  var id: Long = _
  var name: String = _
  var dob: Date = _
}

val user = new User
user.id = 5
user.name = "Foo Quux"
user.dob = ...
\end{lstlisting}

While syntactically valid code, it is very confusing. The \pcode{user} variable is declared immutable, yet it is possible to invoke its setters. The equivalent Java code would declare the \pcode{user} variable \pcode{final}, but then still use the setters to mutate it.

\section{Killer features}
The syntax (and its application) so far looks just like Java with less typing. There must be something else that makes it worth leaving the creature comforts of Java. 

\begin{itemize}
  \item everything is an expression
  \item case classes
  \item pattern matching
  \item for comprehensions
  \item implicits
  \item rich type system
\end{itemize}

\subsection{Everything is an expression.} 
In Java, C, and similar languages, there are statements and expressions. Statements do not have value, they are typical control-flow constructs. For example, in Java, \pcode{if (a == b) X else Y} cannot be assigned to a variable, because \pcode{if-then-else} is a statement. In Scala, everything yields a value that can be assigned to a variable. 

\subsection{Case classes.} A case class is just like a class in that it is a container for data and methods, but the fields it contains only have getters. (Immutability only goes as far as immutability of the references. Even in Scala, immutability without any additional code is equivalent to using \pcode{final} in Java.) Nevertheless, case classes are fantastically convenient to define data structures. Consider the \pcode{Person} case class defined in \autoref{code:cc1}.

\begin{lstlisting}[caption={Case class \pcode{Person}}, label={code:cc1}, language=Scala, escapechar=|]
case class Person(firstName: String, lastName: String, age: Int)
\end{lstlisting}

This is all it takes to define an immutable structure (with the T\&Cs from above) with the fields \pcode{firstName}, \pcode{lastName}, and \pcode{age}; but also with appropriate \pcode{toString}, \pcode{hashCode}, and \pcode{equals} implementations. These automatically generated implementations delegate to the \pcode{toString}, \pcode{hashCode}, and \pcode{equals} methods of all the fields, in the order in which they are specified.

To create an instance of a case class, do not use the \pcode{new} keyword; instead, write the parameters directly after the case class name, as shown in \autoref{code:cc2}.

\begin{lstlisting}[caption={Using case class \pcode{Person}}, label={code:cc2}, language=Scala, escapechar=|]
|Notice that there is no |new| keyword; the parameter values are applied directly after the case class name.|
val fq = Person("Foo", "Quux", 42)

|To access the fields, use the familiar |.| notation.|
fq.firstName | $\rvert$ |"Foo"

|Invoking the |toString| method prints a reasonable representation of the case class.|
fq.toString | $\rvert$ |"Person(Foo,Quux,42)"

|It is possible to vary the order of the parameters if the parameter names are also specified. This can help readability.|
val fb = Person(lastName = "Baz", firstName = "Foo", age = 50)
fb.toString | $\rvert$ |"Person(Foo,Baz,50)"

|Equality is implemented by delegation to the parameters' |hashCode| and |equals| methods.|
Person("Foo", "Quux", 42) == fq  | $\rvert$ |true|, even though they are \emph{different} instances.|
fq == Person("Foo", "Quux", 42)  | $\rvert$ |true|, even though they are \emph{different} instances.|
\end{lstlisting}

The consciseness of Scala's syntax is beginning to show. It would have been much more cumbersome to implement all this (including correct \pcode{hashCode}, \pcode{equals}, and reasonable \pcode{toString}) in Java. Even with correct implementations, it would not have been possible to use \pcode{==} to test for instance equality. 

\begin{example}[Exercise: Using case classes and functions]
Create a new case class \pcode{Person} file in \pcode{src/main/scala/com.acme} from \autoref{code:cc1}. Then use \pcode{List.fill(N)(Person(...))} and useful methods in \pcode{scala.util.Random} to generate $N$ random \pcode{Person} instances. Assign those to a variable.
\begin{itemize}
  \item find the oldest person in the list. (Hint: use \pcode{map}, \pcode{max}, and \pcode{find} functions on the \pcode{List[Person]}.)
  \item find the 10 youngest people in the list. (Hint: use \pcode{sortBy} or \pcode{sortWith}, followed by \pcode{take}.)
\end{itemize}

\begin{lstlisting}[caption={Pattern matching}, label={code:pmex}, language=Scala, escapechar=|]
...

object PersonMain extends App {
  
  List.fill(100) ...  

}
\end{lstlisting}
\end{example}

Case classes are also called \emph{product} types. The word product refers to the possible number of values that a case class can hold. Take \pcode{case class ABC(a: Boolean, b: Boolean, c: Boolean)}: there are eight possible values: \pcode{ABC(false, false, false)}, ..., \pcode{ABC(true, true, true)}. The value $8$ is the result of \emph{multiplying} the possible values of all parameters. \pcode{Boolean}s have two values; three \pcode{Boolean} values yield $2 \times 2 \times 2$ possible values of the \pcode{ABC} type. Similarly, \pcode{case class IB(i: Int, b: Boolean)} has $4294967295 \times 2$ possible values. 

Imagine, for a moment, that \pcode{Boolean} is not a built-in primitive. It would be defined as the \emph{sum} of two [degenerate] products of 1 value: \pcode{sealed trait Boolean; case object True extends Boolean; case object False extends Boolean}. The products \pcode{True} and \pcode{False} have exactly one value; consequently, the sum type \pcode{Boolean} has $1 + 1$ possible values. Languages like Haskell\cite{haskell}, F\#\cite{fsharp}, and others have convenient syntax for sum types; see \autoref{code:sum-scala}.

\begin{lstlisting}[label={code:sum-haskell}, language=Haskell, escapechar=@]
@Defines the data type @Boolean@ as a sum of two products, but each product only has one value.@
data Boolean = True   
             | False

@Defines the subscription type as either a ``one-off'' that carries a particular end-date, or a recurring@
@subscription that carries the start date and the billing period.@
data Subscription = OneOff Date 
                  | Recurring Date Period
\end{lstlisting}
\begin{lstlisting}[caption={Sum types}, label={code:sum-scala}, language=Scala, escapechar=|]
sealed trait Boolean
case object True extends Boolean
case object False extends Boolean

sealed trait Subscription
case class OneOff(endDate: Date) extends Subscription
case class Recurring(startDate: Date, period: Period) extends Subscription
\end{lstlisting}

Finally, using the keyword \pcode{sealed} specifies that the trait cannot be extended outside the current source file. This allows the Scala compiler to verify that pattern matches (using the \pcode{match ... case} construct) cover every possible case, reporting a warning if a case is missed.

Sums of products are very useful way to express alternatives that might not have anything in common other than being of the given type, without clumsy \pcode{instanceof} checks with pattern matching.

\subsection{Patten matching.} 
A pattern match is a way to check that a value has the right ``shape'', and to pull out some or all values from that shape. Think of the simplest pattern matching expression as Java's \pcode{switch} statement in \autoref{code:pm1}.

\begin{lstlisting}[caption={Pattern matching}, label={code:pm1}, language=Scala, escapechar=$]
$This is the equivalent of Java's $switch$ statement, with multi-case and a default case.$
Random.nextInt(10) match {
  $Matches values 0..3$
  case 0|1|2|3 =>
  $Matches only value 6$
  case 6 =>
  $Matches all other values$
  case _ =>
}
\end{lstlisting}

It is possible to match on much more complicated structures; such as tuples. A tuple is a collection of a specific length with elements of arbitrary types. For example \pcode{(1, "foo")} is a tuple of 2 elements of types \pcode{Int} and \pcode{String}; \pcode{("foo", "bar", 1.3)} is a tuple of 3 elements of types \pcode{String}, \pcode{String}, and \pcode{Double}. It is possible to pattern match on those, as shown in \autoref{code:pm2}

\begin{lstlisting}[caption={Pattern matching II}, label={code:pm2}, language=Scala, escapechar=|]
import scala.util.Random
(Random.nextString(Random.nextInt(16)), Random.nextInt(100)) match {
  |Matches tuples with any first element, and second element |== 10|.|
  case (s, 10)                          => |The first element is accessible as |s| here.|

  |Matches only the |("Lucky?", 42)| tuple.|
  case ("Lucky?", 42)                   => |None of the elements are accessible here.|

  |Matches any tuple as long as the first element is longer than 5 characters and second element is less than 10.|
  case (x, y) if x.length > 5 && y < 10 => |Both first and second elements are accessible as |x| and |y|.|
  
  |Matches any value|
  case _                                => |None of the elements are accessible here.|
}
\end{lstlisting}

As useful as tuples are for quick ad-hoc structures, the real deal in pattern matching are case classes. Just like matching on a tuple, it is possible to match on case classes and extract their fields as needed. In addition to using the \pcode{match} keyword followed by \pcode{case}s, pattern matching also applies to declarations of variables in \autoref{code:pm3}.

\begin{lstlisting}[caption={Pattern matching III}, label={code:pm3}, language=Scala, escapechar=|]
|Pattern matches on the right-hand side, pulls out the first parameter as |val first: String|.|
val Person(first, _, _) = Person("Foo", "Bar", 99)

|Pattern matches on the right-hand side, comparing the value of the first parameter to be equal to in-scope variable |first|. (Notice the backticks.)|
val Person(`first`, _, _) = Person("Foo", "Bar", 99)

|Because there are no alternatives, if the |val| pattern match fails, it raises an exception.|
val Person(`first`, _, _) = Person("Fooz", "Bar", 99)
\end{lstlisting}

The pattern match that raises an exception if it fails is often convenient to use in tests. Suppose there 

\begin{example}[Exercise: Using case classes and pattern matching]
Build an numerical expression evaluator; the evaluator should support binary operators $+, -, \times, /$ and support arbitrary nesting. It should be able to evaluate, for example $4+3(5/(12-7))$. To make things simpler, it is not necessary to include error reporting (division by zero, for example), and it is not necessary to provide a way to turn a \pcode{String} into an expression.

\begin{lstlisting}[caption={Expression evaluator}, label={code:ee}, language=Scala, escapechar=|]
|The sum type Expr's subtypes define the ``operations'' we support.|
sealed trait Expr
|The different cases need to support our operations and constants.|
case class Plus(left: Expr, right: Expr) extends Expr
...
case class Const(const: Int) extends Expr

|It will be convenient to package our evaluator in its own module.|
object Evaluator {
  
  |Hint: you will need to pattern-match on the different |Expr|s.|
  def eval(expr: Expr): Int = expr match {
    case Const(x) => x
    ...
  }

}

object EvaluatorMain extends App {

  val e = Evaluator.eval(Plus(Plus(Const(4), Const(5)), Const(3)))
  println(e) | $\rvert$ \Printer{ }|12

}
\end{lstlisting}
\end{example}

\begin{example}[Exercise (extra): logical expression simplifier]
Build a logical expression simplifier that reduces the number of logical operations to be performed, and can spot tautologies and contraditions. For example, $(a \land b) \lor (a \land b)$ should simplify to just $a \land b$; $(a \lor \lnot{a})$ should simplify to $\top$ (tautology; always true); $(a \lor \lnot{a}) \land (a \oplus a)$ should simplify to $\bot$ (contradiction; always false).

\begin{lstlisting}[caption={Logical expression simplifier}, label={code:ls}, language=Scala, escapechar=|]
|The sum type LExpr defines the different logical expressions we support.|
sealed trait LExpr

|The different cases need to support our operations and constants.|
case class LAnd(left: LExpr, right: LExpr) extends LExpr
case object Contradiction extends LExpr
...
case class Var(named: String) extends LExpr

|Just like the evaluator, package the simplifier in its own module.|
object Simplifier {
    
  |Hint: you will need to pattern-match on the different |LExpr|s.|
  def simplify(expr: LExpr): LExpr = expr match {
    ...
  }

}

object SimplifierMain extends App {

  val se = Simplifier.simplify(
    LAnd(
      LOr(Var("a"), LNot(Var("a"))),
      LXor(Var("a"), Var("a"))
    )
  )
  println(se) | $\rvert$ \Printer{ }|"Contradition"

}
\end{lstlisting}
\end{example}

\subsection{For comprehensions}
TODO
 
\subsection{Implicits} 
Implicits are one of the key features of Scala. As the word suggests, implicit parameter values are supplied ``automatically'' by the compiler looking for the appropriate values in the current \emph{implicit scope}\footnote{The implicit scope is somewhat complex; for now, it will be sufficient to remember that implicit scoping is similar to regular visibility scoping}. The look-up ignores the parameter names, it only cares about the types. Implicits also apply when the compiler encounters an identifier on a value of some type that the type does not implement. In that case, the compiler will follow the same implicit scoping rules to find an implicit conversion that turns the given type into another type that contains the identifier. 

\begin{lstlisting}[caption={Simple implicits}, label={code:implicits1}, language=Scala, escapechar=|]
object SimpleImplicitsMain extends App {
  |Defines an implicit conversion from a |String| into |LoudString|, which adds the method |LOUD|.|
  implicit class LoudString(s: String) {
    def LOUD: String = s.toUpperCase() + "!!"
  }

  |Define the implicit value of type |String|.; notice the implicit application of the |LoudString.LOUD|.|
  implicit val completelyArbitraryName: String = "Hello, world".LOUD

  |The |sayHello1| method has single implicit parameter list, with one parameter of type |String|.|
  def sayHello1(implicit greeting: String): Unit = println(greeting)

  |The |sayHello2| method has two parameter lists, one empty, and one implicit with one parameter of type |String|.|
  def sayHello2()(implicit greeting: String): Unit = println(greeting)

  sayHello1    | $\rvert$ to apply, omit the implicit parameter list, leaving just |sayHello1|.|
  sayHello2()  | $\rvert$ to apply, omit the implicit parameter list, leaving just |sayHello2()|.|
}
\end{lstlisting}

Defining implicit \pcode{String}s demonstrates the principle, but it is rather useless because values of type \pcode{String} are so ubiquitous in typical programs. Different types are sometimes more useful; consider a \pcode{javax.sql.Connection} which might be passed implicitly to various data access code to avoid having to do too much typing. The ability to turn values into values that contain identifiers that are not available on the original types are also quite useful. The real power, though, comes from the fact that the implicit resolution does not stop at the first step. The compiler follows all possible paths, using as many conversions as necessary, to get the code to compile. 

\paragraph{Pimp my library.} Providing implicit conversions from existing types to other types that contain useful or convenient identifiers is called \emph{pimp my library}. It is a fancy name for the adapter pattern\cite{adapter-pattern}, but implicits provide the convenience to avoid having to create instances of the adapters manually. It is a useful way to construct domain-specific languages, particularly when combined with Scala's ability to call single parameter method without dots and braces, as though it were an operator.

\begin{lstlisting}[caption={Pimp my library}, label={code:pml1}, language=Scala, escapechar=|]
implicit class RichDouble(x: Double) {
  def ^(y: Double): Double = math.pow(x, y)
}

val x: Double = 42
x ^ 2 | $\rvert$ Computes the second power of |x| by essentially doing |new RichDouble(x).^(2)|.|
\end{lstlisting}

\begin{example}[Exercise: Pimp my library]
Build a DSL that allows the expression evaluator to be written using natural-looking Scala code--though sadly not using the standard \pcode{+, -, *, /} operators, but using our own \pcode{plus, minus, mult, div} instead. The expression \pcode{5 plus 10} should evaluate to \pcode{Plus(Const(5), Const(10))}. The type \pcode{Int} and \pcode{Expr} do not contain the methods \pcode{plus}, ..., \pcode{div}; it will be necessary to implement implicit conversions (use \pcode{implicit class} for convenience) that contains those methods. 

\begin{lstlisting}[caption={Expression evaluator}, label={code:eepm}, language=Scala, escapechar=|]
|It will be useful to package the PML conversions in their own module.|
object Expr {
  |Two conversions will be necessary: |Int -> Expr|, |Expr -> RichExpr|. The two P.M.L. implicit classes|
  |will contain the same functions; the only exception is that the one for |Int| will need to box the given|
  Int| into |Const|.|
  implicit class RichInt(x: Int) {
    def plus(that: Expr): Expr = Plus(Const(x), that)
    ...
  }
  implicit class RichExpr(x: Expr) {
    def plus(that: Expr): Expr = Plus(x, that)
    ...
  }

}

object EvaluatorMain extends App {
  import Expr._
  val e = Evaluator.eval((5 plus 10) minus 8)
  println(e)
}
\end{lstlisting}

Hints: \begin{itemize}
  \item because the methods \pcode{plus(r: Expr): Expr}, ..., \pcode{div(r: Expr): Expr} would be the same, consider defining them in a trait (\pcode{trait ExprOps} would be a jolly good name!) that is then mixed into the implicit classes, where the trait defines abstract member \pcode{self: Expr}, which is then used as the left-hand side in the \pcode{Expr} data constructors; the right-hand side coming from the parameter of the method.
  \item implementing a class that adds the methods \pcode{plus}, ..., \pcode{div} to \pcode{Int} will allow for code such as \pcode{10 plus Const(5)}, but it will not compile \pcode{10 plus 5}, because there is no function \pcode{plus}, ..., \pcode{div} that takes an \pcode{Int}. The preferred option is to add those over implicit conversion from \pcode{Int} to \pcode{Expr}: \pcode{implicit def intToExpr(i: Int): Expr} is generally frowned-upon because it allows silent and potentially very powerful conversions.
\end{itemize}

If you are feeling inventive or perhaps mischievous, pick Unicode identifiers for the boring ASCII method names in the DSL. Resurrect APL by using ÷ instead of \pcode{div}!
\end{example}

\paragraph{Type classes.} Type class is a concept from Haskell\cite{haskell}; it is a definition of methods that can be implemented for some type. A type class is therefore an interface parametrized by a type; the implementations are instances of this interface for some types. Suppose the expression evaluator needs to be able to evaluate not just \pcode{Int}s, but also other number-like values. The only change to its structure is an interface that implements the addition, subtraction, multiplication, and division for \emph{some} number-like type; see \autoref{code:eewt1}.

\begin{lstlisting}[caption={Expression evaluator without typeclasses}, label={code:eewt1}, language=Scala, escapechar=|]
|Define the typeclass that defines the methods that instances for the type |A| must implement.|
trait NumberLike[A] {
  def plus(x: A, y: A): A
  ...
  def div(x: A, y: A): A
}

sealed trait Expr
...
|Modify the |Const| data constructor to take any type |A| instead of the concrete |Int|.|
case class Const[A](a: A) extends Expr

object Evaluator {
 
  |The |eval| function now needs to take the interface that implements the number-like behaviour for type |A|.| 
  def eval[A](expr: Expr, numberLike: NumberLike[A]): A = expr match {
    case Plus(l, r) => numberLike.plus(eval(l, numberLike), eval(r, numberLike))
    ...
    case Const(a: A) => a
  }

}

object EvaluatorMain extends App {
  import Expr._
  import Evaluator._
  
  val expr = 5 plus 10
  eval(expr, new NumberLike[Int] {
    def plus(x: Int, y: Int): Int = x + y
    ...
    def div(x: Int, y: Int): Int = x / y
  }) | $\rvert$ evaluates to |15|.|

}
\end{lstlisting}

This is rather tedious to write, especially all the points where the \pcode{numberLike} instance has to be passed around to the recursive calls of \pcode{eval}. Moving it to the implicit parameter list makes the code cleaner in \autoref{code:eewt2}.

\begin{lstlisting}[caption={Expression evaluator with typeclasses-ish}, label={code:eewt2}, language=Scala, escapechar=|]
trait NumberLike[A] { ... }

object Evaluator {
 
  def eval[A](expr: Expr)(implicit N: NumberLike[A]): A = expr match {
    case Plus(l, r) => N.plus(eval(l), eval(r))
    ...
    case Const(a: A) => a
  }

}

object EvaluatorMain extends App {
  import Expr._
  import Evaluator._
  
  val expr = 5 plus 10
  eval(expr)(new NumberLike[Int] {...}) | $\rvert$ evaluates to |15|.|

}
\end{lstlisting}

This is an improvement, though it is still annoying to have to explicitly specify the value of the \pcode{numberLike} parameter in the implicit (sic!) parameter list in \pcode{EvaluatorMain}. The Scala compiler is able to find the implicit value, if one is available in the implicit scope; all that remains to be done is to provide an \emph{instance of the \pcode{NumberLike} typeclass for the type \pcode{Int}}, and any other required types. (Viz \autoref{code:eewt3}.)

\begin{lstlisting}[caption={Expression evaluator with typeclasses}, label={code:eewt3}, language=Scala, escapechar=|]
trait NumberLike[A] { ... }

object EvaluatorMain extends App {
  import Expr._
  import Evaluator._

  implicit object IntNumberLike extends NumberLike[Int] {
    def plus(x: Int, y: Int): Int = x + y
    ...
  }
  
  |Complex numbers are numbers too!|
  case object Complex {
    val e: Complex = ...
    val pi: Complex = ...
    val i: Complex = ...
  }
  case class Complex(re: Double, im: Double) {
    def +(rhs: Complex): Complex = ...
    def ^(rhs: Complex): Complex = ...
  }
  implicit object ComplexNumberLike extends NumberLike[Complex] {
    def plus(x: Complex, y: Complex): Complex = x + y
    ...
  }
  
  |And now the evaluator works for any type |A| that lies in the |NumberLike| typeclass; i.e. where there is an in-scope|
  |way to access or follow steps to create instances of |NumberLike[A]|.|
  eval[Int](5 plus 10)        | $\rvert$ evaluates to |15|.|
  eval[Complex](e ^ (pi * i)) | $\rvert$ evaluates to |-1|.|

}
\end{lstlisting}


\begin{example}[Exercise: Flexible evaluator]
Allow the expression evaluator to operate on any number-like types, not just \pcode{Int}s. Instead of relying on inheritance, forcing all users of the evaluator to evaluate values conforming to some trait (with the number-crunching methods \pcode{+, -, *, /}), use parametric polymorphism and type classes. The \pcode{Const} data constructor will need to take any type instead of \pcode{Int}; \pcode{RichInt} implicit class will need to pimp any type, not just \pcode{Int}; the \pcode{eval} method will also need to be generic, but will need to (implicitly) require a typeclass: use the \pcode{Fractional} provided by the standard library, or define your own \pcode{NumberLike} typeclass. (The Scala standard library defines \pcode{Fractional} and \pcode{Integral} type classes, which contain the division operation whereas \pcode{Numeric} typeclass does not. Pick one, the limitation that not all types are fractional or integral. ``Dotty will fix this!'')

\begin{lstlisting}[caption={Flexible evaluator with DSL and typeclasses}, label={code:eepm3}, language=Scala, escapechar=|]
object Expr {

  trait ExprOps {
    def self: Expr
    def plus... |This will need to take generic type |A|.|
    ...
  }

  implicit class RichA... |This will need to take generic type |A|.|
  implicit class RichExpr(val self: Expr) extends ExprOps

}

sealed trait Expr
...
case class Const... |This will need to take generic type |A|.|

object Evaluator {

  |It will be convenient to use the full implicit syntax here|
  def eval[A](expr: Expr)...: A = expr match {
    ...
  }

}

object EvaluatorMain extends App {
  import Expr._
  |The point of application constrains the generic parameter, it is necessary to specify the type |A|. in |eval|.|
  val e = Evaluator.eval[Double]((5.4 plus math.Pi) minus 8.8)
  ...
}
\end{lstlisting}

Hints: \begin{itemize}
  \item it is not necessary to constrain the type of the \pcode{Const} data constructor; it can be ``forall A.'' \pcode{Const[A]}.
  \item it will be convenient to use the full implicit syntax in the \pcode{eval} method: \pcode{def eval[A](expr: Expr)(implicit N: Fractional[A]): A} instead of \pcode{def eval[A : Fractional](expr: Expr): A}
  \item the type information for the generic type \pcode{A} will be erased, causing compiler warning in the pattern match. It is possible to eliminate the warning by using another type class. Look for \emph{Scala type tags and manifests}.
\end{itemize}

\end{example}

Unlike subtype polymorphism, typeclasses bring \emph{parametric polymorphism}. Parametric polymorphism is a different way of requiring values to contain specified behaviour. Subtype polymorphism for the evaluator would require the values in the \pcode{Const} data constructor to be some supertype of all numbers. That does not sound so bad until one realises that the methods \pcode{plus}, ..., \pcode{div} in this supertype would have to return that supertype. Imagine in \autoref{code:num} that it is possible to extend the types in \pcode{scala.lang}, like \pcode{Int}.

\begin{lstlisting}[caption={Exploring the Num supertype}, label={code:num}, language=Scala, escapechar=|]
trait Num {
  def plus(that: Num): Num
  def minus(that: Num): Num
  ...
}

|This isn't actually allowed, but humour the author.|
class MyInt extends Int with Num {
  |Attempts to implement the |Num| trait won't be successful...|
  def plus(that: Num): Num = this + that 
                                  |$\uparrow$ this doesn't quite work: can't add |Int| and |Num|.|

  |Or the implementation won't at all be satisfying.|
  def plus(that: Num): Num = that match {
    case x: MyInt => this + x
    case _ => 
         |$\uparrow$ now what? throw exception?; add |toInt()| method to |Num|?|
  }
}

|This is Scala's common approach to static |of|-like methods in Java. Recall |Optional.of| and similar.|
object MyInt {
  def apply(i: Int): MyInt = new MyInt(i)
}

|But never mind all above, the show must go on.|
case class Const(a: Num) extends Expr

def eval(expr: Expr): Num = expr match {
  case Plus(l, r) => eval(l).plus(eval(r))
  ...
}

|I allowed |Int| to be extended; requiring integer literals to be instances of |MyInt| is too much!|
|Using the |object MyInt.apply| allows us to avoid the |new| keyword in this case.|
val e = Evaluator.eval(MyInt(5) plus MyInt(3) minus MyInt(1))
    |$\uparrow$ the type of |e| is |Num|, even though |MyInt| was used.|
\end{lstlisting}

The code in \autoref{code:num} is bad enough \emph{now}, but it has the potential to become much \emph{worse} if it becomes widely used. The authors of the code were able to implement sensible inheritance structure for \pcode{MyInt}s, \pcode{MyDouble}s, even \pcode{MyBigDecimal}s and shipped the JAR. Then someone else decided to use the expression evaluator for complex numbers; but even with the implementation of \pcode{class Complex extends Num \{...\}}, it is still possible to call \pcode{MyInt(5).plus(Complex(1, 4))}. The class \pcode{MyInt} has no knowledge about the \pcode{Complex} class! (Exactly what happens in that call depends on the implementation of the \pcode{MyInt.plus} method, but it won't be pretty.)

Parametric polymorphism, as demonstrated in your own work on the Flexible evaluator exercise, presents a neat solution. It is possible to use typeclasses to add behaviour for concrete types without losing the concreteness.

\subparagraph{A remark on Haskell.} Scala's take on typeclasses should clarify Haskellers' usual statement that ``typeclasses are not like OOP classes, they are more like interfaces.'' Quite: a typeclass is an interface with a type parameter that defines behaviour for the type. Its implementations specify a concrete type and implement the behaviour. Typeclass instances are then regular values (remember the singletons from the Scala code?) that implement the typeclass interface.

\begin{lstlisting}[language=Scala, escapechar=|]
|Require the type |A| to have an instance of the |NumberLike| trait available for it.|
|Compiler will supply the value in the parameter |N| of the implicit parameter list.|
def eval[A](expr: Expr)(implicit N: NumberLike[A]): A = expr match {
  |Call the typeclass's methods using the standard method call notation.|
  case Plus(l, r) => N.plus(l, r)
  ...
}
\end{lstlisting}

\begin{lstlisting}[language=Haskell, escapechar=|]
|Define the typeclass |NumberLike| for type |a| with methods like |plus|, ... .|
class NumberLike a where
  plus :: a -> a -> a
  ...

|Provide an instance of |NumberLike| for the type |Int|.|
instance NumberLike Int where
  plus x y = `addl %rdx, %rax` | $\rvert$ Hoping that we have fastcall convention and the parameters are in |%rax| and |%rdx|.|
  ...

|Provide an instance of |NumberLike| for the type |Complex|.|
instance NumberLike Complex where
  ...

|Just like the Scala version, |eval| requires the type |a| to lie in the |NumberLike| typeclass;|
|that is, that there is an instance of |NumberLike| for that |a|.|
eval :: (NumberLike a) => Expr -> a

|However, the typeclass instance does not get a name in the function. Instead, all its functions|
plus|, ... are available in the function without any additional notation.|
eval (Plus l r) = plus (eval l) (eval r)
                  |$\uparrow$|
                  |In Scala, this would be |N.plus(eval(l), eval(r))
\end{lstlisting}


\subsection{Rich type system.}
Variance. Kinds \& Type constructors. Higher-kinded types.

\begin{example}[Exercise: Flexible evaluator II]
Explore and explain the difference in just adding the generic parameter to the \pcode{Const} data constructor (leaving \pcode{sealed trait Expr} intact), or letting \pcode{Expr} become \pcode{sealed trait Expr[A]}. Explain the effects of covariant type parameter in \pcode{sealed trait Expr[+A]}. (Try \pcode{val e: BigDecimal = Evaluator.eval(Const(4))} with invariant \pcode{Expr} and then with covariant \pcode{Expr} to get started.)

\begin{lstlisting}[caption={Variance}, label={code:variance}, language=Scala, escapechar=|]


\end{lstlisting}
\end{example}


\section{The standard library}
The Scala standard library defines many standard structures in case classes. Picking the two most useful ones, \pcode{Option} and \pcode{Either} are defined as case classes. This means that it is possible to pattern match on their values.

\begin{lstlisting}[caption={Pattern matching in stdlib}, label={code:pm4}, language=Scala, escapechar=|]
|These are the definition in the standard library; note that the actual definitions are more complex, but this code expresses the essence.|

Option[A]| has two alternatives: |Some[A]| and |None|. It is used to express one-or-missing values.|
sealed trait Option[A]
case class Some[A](a: A) extends Option[A]
case object None extends Option[Nothing]

Either[L, R]| has also two alternatives: |Left[L]| and |Right[R]|. It is used to express success or failure, with success by convention|
|on the right and failure on the left.|
sealed trait Either[L, R]
case class Right[R](r: R) extends Either[Nothing, R]
case class Left[L](l: L) extends Either[L, Nothing]
\end{lstlisting}

...


\section{Spring Framework}
The Spring Framework is a dependency injection framework; it encourages composition over inheritance, it encourages expressing dependencies as interfaces rather than concrete implementations. The framework takes care of instantiating the components in the correct order; most components (the ones that fall into the \pcode{@Component} stereotype) are \emph{singletons}. This means that it is possible to treat the \pcode{@Component}-annotated components as namespaces rather than containers of state\footnote{In fact if the methods in \pcode{@Component}-annotated classes mutates \& accesses its fields, it will suffer from race conditions.}. The reason why Spring Framework encourages programming to interfaces is to make the software easily testable: there can be separate implementations or mocks for unit and integration tests.

\begin{lstlisting}[caption={Components}, label={code:sf1-java}, language=Java, escapechar=|]
interface ReportGenerator {
    |Generates the PDF report for the given $user$,|
    |returns the byte array representing the PDF contents|
    byte[] generate(final String user);
}

@Component
public class ReportService {
    private final ReportGenerator reportGenerator;

    @Inject
    public ReportService(final ReportGenerator reportGenerator) {
        this.reportGenerator = reportGenerator;
    }

    public void reportAll() {
        for (final String user : Arrays.asList("a", "b", "c")) {
            final byte[] pdf = this.reportGenerator.generate(user);
            |Now you're on your own...|
        }
    }
 }
\end{lstlisting}

For a Spring Framework application to be able to construct the \pcode{ReportService}, it needs to be able to construct exactly one component that implements the \pcode{ReportGenerator} interface.

\begin{lstlisting}[caption={Components}, label={code:sf2-java}, language=Java, escapechar=|]
@Component
public class JasperReportsReportGenerator implements ReportGenerator {
    public byte[] generate(final String user) {
        ...
    }
}
\end{lstlisting}

Without a DI framework, the work of constructing the dependencies would fall on the programmers, yielding code similar to \autoref{code:sf3-java}.

\begin{lstlisting}[caption={Manual DI}, label={code:sf3-java}, language=Java, escapechar=|]
|Typically in |public static void main(String[] args) |or in a test:|

ReportGenerator rg = new JasperReportsReportGenerator();
ReportService rs = new ReportService(rg);
\end{lstlisting}

Constructing the instances of the \pcode{JasperReportsReportGenerator} and \pcode{ReportService} using their constructors isn't a problem per se, but with growing number of dependencies this grows to be tedious.


\section{Zero to hundred}
FizzBuzz is a typical program that follows \emph{Hello, world}, adding iteration and conditions. The Scala version of FizzBuzz is shown in \autoref{code:fb1}--it shows the definition of a function \pcode{def}, followed by name and arguments, and its implementation that follows the \pcode{=} sign. The loop (\pcode{for}) and condition (\pcode{if}, \pcode{else}) keywords are the old friends from other languages. 

\begin{lstlisting}[caption={Fizz Buzz}, label={code:fb1}, language=Scala, escapechar=|]
def fizzBuzz = {
  for (i <- 1 to 100) {
    if (i % 15 == 0) println("FizzBuzz")
    else if (i % 3 == 0) println("Fizz")
    else if (i % 5 == 0) println("Buzz")
    else println(i)
  }
}
\end{lstlisting}

The FizzBuzz from \autoref{code:fb1} isn't particularly re-usable: it simply prints 100 elements to the standard output, nothing else and nothing more. There is no way, for example, to direct the output to a web socket, or to use it to determine how it maps of the value in the \pcode{integer} domain to the ``FizzBuzz domain''. Hmm!--\emph{mapping} and \emph{domain} sound like mathematics; and functional programming is supposed to be somehow more mathematical. And mathematics is jolly wonderful. 

The first step in making the \pcode{fizzBuzz} more mathematical is to make it map an input to exactly one useful output. Right now, its return type now is \pcode{Unit}, which is a bit like \pcode{void} in Java and C; changing its definition to \pcode{def fizzBuzz2(max: Int): Unit} (and then using the \pcode{max} parameter in the loop) isn't particularly useful: it is a mapping from a number to \pcode{Unit}. And, if this were mathematics, there can be only one such mapping: \pcode{def fizzBuzz2(max: Int): Unit = ()}. Instead of printing the elements to the console, the implementation needs to return a value that can be printed. A a simple \pcode{String} would do, but a \pcode{Seq} of \pcode{String}s is better. The type becomes \pcode{Int => Seq[String]}, and the implementation is shown in \autoref{code:fb2}.

\begin{lstlisting}[caption={Fizz Buzz}, label={code:fb2}, language=Scala, escapechar=|]
def fizzBuzz(max: Int): Seq[String] = {
  var result = List.empty[String]
  for (i <- 1 to max) {
    if (i % 15 == 0) result = result :+ "FizzBuzz"
    else if (i % 3 == 0) result = result :+ "Fizz"
    else if (i % 5 == 0) result = result :+ "Buzz"
    else result = result :+ i.toString
  }
  result
}
\end{lstlisting}

This is a huge improvement! The \pcode{fizzBuzz} is now indeed a function: it maps input to output and its result depends only on the value of the parameter. It would even be possible to pre-compute the result for all possible values of the input and replace the function's body with a look-up in that table: the function would become just data! 

Well, the outside looks great, but the implementation stinks! It uses mutation, and what about the strange \pcode{:+} operator in \pcode{result :+ "Fizz"}, never mind the \pcode{for (i <- 1 to max) \{...\}} nonsense!

\begin{lstlisting}[caption={Fizz Buzz}, label={code:fb3}, language=Scala, escapechar=|]
def fizzBuzz(max: Int): Seq[String] = {
  def fb(i: Int): String =
    if (i % 15 == 0) "FizzBuzz"
    else if (i % 3 == 0) "Fizz"
    else if (i % 5 == 0) "Buzz"
    else i.toString

  (1 to max).map(fb)
}
\end{lstlisting}




In Scala, every concrete type (except \pcode{Nothing}) can have a value: for example, the type \pcode{Boolean} is inhabited by values \pcode{true, false}; the type \pcode{Int} is inhabited by values such as \pcode{5, 42, -100, 0, ...}; the type \pcode{String} is inhabited by values such as \pcode{"Hi", ":)", ""}; the type \pcode{Unit} is inhabited by the only value \pcode{()}. (No, really, it's perfectly good Scala syntax to write \pcode{()} as value. It's just not particularly useful.) The only type that does not have any inhabitants is \pcode{Nothing}: it represents expressions that \emph{diverge}, for example throwing an exception.

Taking a more precise look at \pcode{def fizzBuzz} reveals its type to be \pcode{Unit}; it evaluates to only one value, namely \pcode{()}. If it were a function in the sense of strictly mapping input to output, it would be no different from any other \pcode{()} \emph{constant}. But \pcode{fizzBuzz} does some additional work before returning \pcode{()}; this additional work is not represented by its type, even though it is its \emph{raison d'être}. 

In Java and C, there is no \emph{value} of type \pcode{void}

 As it stands, its type is \pcode{() => Unit}, 

\newpage

\section{Pattern matching}
sasd
\newpage

\section{}

\printbibliography

\end{document}
