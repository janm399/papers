\documentclass[10 pt]{article}
\input{../../common.tex}

\usepackage[OT1]{fontenc}
\newcommand*\eiadfamily{\fontencoding{OT1}\fontfamily{eiad}\selectfont}

\addbibresource{root.bib}

\title{Scala Tutorial I}

\author{Jan Macháček}

\begin{document}

\maketitle
\begin{abstract}
  Scala is a fusion langauge that combines functional and object-oriented programming paradigms in a syntax that is similar to most other \emph{C-like} languages. The ...
\end{abstract}
\bigskip

\section{Syntax crash-course}
Scala's syntax follows the syntax of other C-like languages, though--like Pascal--the type specification follows an identifier. Scala's \pcode{class} behaves exactly like Java's \pcode{class}, and its synax is not wildly different. (See \autoref{code:syntax-class}.)

\begin{lstlisting}[caption={Classes and methods}, label={code:syntax-class}, language=Scala, escapechar=|]
|Class declaration means the same thing as Java; constructor parameters are specified in the block immediately following the class name.|
|Note that the types follow the identifier; instead of |String constructorParam1| Scala uses |constructorParam1: String
class MyClass(constructorParam1: String, constuctorParam2: Int) {
  
  |Methods begin with the keyword |def|, followed by name and parameters. The return type follows similar pattern; |Unit| means |void.
  |The body of the method follows the equals sign.|
  def execute(methodParam1: List[Int]): Unit = {

  }

}

|Constructing instances uses the typical |new| keyword...|
new MyClass("foo", 42)
  |Method invocation is exactly like Java's|
  .execute(List(1, 2, 3))
\end{lstlisting}

Most of this syntax is familiar and unsurprising; the only thing that might feel odd is the square bracket for ``generics'' in \pcode{List[Int]}: in Java, this would be written as \pcode{List<Int>}. This is part of Scala's legacy. A long, long time ago, XML was very exciting; and Scala allows XML literals. These XML literals use the angle brackets. This meant that a different symbol had to be used for type parameters. Because the square bracket is used for type parameters, array indexing is also done using regular parentheses\footnote{I know, it looks like VisualBasic or Fortran (formerly FORTRAN)!}.

Interfaces use the \pcode{trait} keyword in Scala; their usage and features are similar to \pcode{interface} in Java (particularly Java 8 which adds default implementations). It is possible to make anonymous implementations of a \pcode{trait}, as well as to implement it in ordinary \pcode{class}es. (Viz \autoref{code:syntax-trait}.)

\begin{lstlisting}[caption={Traits}, label={code:syntax-trait}, language=Scala, escapechar=|]
|Apart from the |trait| keyword, the syntax is unremarkable|
trait ReportGenerator {
  |Interface methods are public and abstract; they specify parameters and return type|
  def generate(userId: Int): Array[Byte]
}

|A |trait| can be implemented in a |class| using the keyword |extends|. Additional traits to be implemented use the |with| keyword.|
class ReportGeneratorImpl extends ReportGenerator with Cloneable {
  |Instead of the |@Override| annotation Scala uses the |override| keyword.|
  override def generate(userId: Int): Array[Byte] = ...
  override def clone(): AnyRef = ...
}

|It is also possible to make an anonymous implementation of a trait using the |new| keyword.|
new ReportGenerator {
  override def generate(userId: Int): Array[Byte] = ...
}
\end{lstlisting}

It is worth noting that there is no special syntax for \emph{array of X} in Scala. Instead, it uses \pcode{Array} with the specified type parameter. (So, Java's \pcode{byte[]} becomes \pcode{Array[Byte]}, \pcode{User[]} becomes \pcode{Array[User]}, and so on.) Also notice the \pcode{AnyRef} in the implementation of the \pcode{clone()} method--it is equivalent to \pcode{java.lang.Object}.

\section{Killer features}
To a modern Java programmer, Scala comes with five killer features, which make everyday programming tasks much easier.

\begin{itemize}
  \item everything is an expression
  \item case classes
  \item pattern matching
  \item for comprehensions
  \item implicits
  \item rich type system
\end{itemize}



\section{Spring Framework}
The Spring Framework is a dependency injection framework; it encourages composition over inheritance, it encourages expressing dependencies as interfaces rather than concrete implementations. The framework takes care of instantiating the components in the correct order; most components (the ones that fall into the \pcode{@Component} sterotype) are \emph{singletons}. This means that it is possible to treat the \pcode{@Component}-annotated components as namespaces rather than containers of state\footnote{In fact if the methods in \pcode{@Component}-annotated classes mutates \& accesses its fields, it will suffer from race conditions.}. The reason why Spring Framework encourages programming to interfaces is to make the software easily testable: there can be separate implementations or mocks for unit and integration tests.

\begin{lstlisting}[caption={Components}, label={code:sf1-java}, language=Java, escapechar=|]
interface ReportGenerator {
    |Generates the PDF report for the given $user$,|
    |returns the byte array representing the PDF contents|
    byte[] generate(final String user);
}

@Component
public class ReportService {
    private final ReportGenerator reportGenerator;

    @Inject
    public ReportService(final ReportGenerator reportGenerator) {
        this.reportGenerator = reportGenerator;
    }

    public void reportAll() {
        for (final String user : Arrays.asList("a", "b", "c")) {
            final byte[] pdf = this.reportGenerator.generate(user);
            |Now you're on your own...|
        }
    }
 }
\end{lstlisting}

For a Spring Framework application to be able to construct the \pcode{ReportService}, it needs to be able to construct exactly one component that implements the \pcode{ReportGenerator} interface.

\begin{lstlisting}[caption={Components}, label={code:sf2-java}, language=Java, escapechar=|]
@Component
public class JasperReportsReportGenerator implements ReportGenerator {
    public byte[] generate(final String user) {
        ...
    }
}
\end{lstlisting}

Without a DI framework, the work of constructing the dependencies would fall on the programmers, yielding code similar to \autoref{code:sf3-java}.

\begin{lstlisting}[caption={Manual DI}, label={code:sf3-java}, language=Java, escapechar=|]
|Typically in |public static void main(String[] args) |or in a test:|

ReportGenerator rg = new JasperReportsReportGenerator();
ReportService rs = new ReportService(rg);
\end{lstlisting}

Constructing the instances of the \pcode{JasperReportsReportGenerator} and \pcode{ReportService} using their constructors isn't a problem per se, but with growing number of dependencies this grows to be tedious.


\section{Zero to hundred}
FizzBuzz is a typical program that follows \emph{Hello, world}, adding iteration and conditions. The Scala version of FizzBuzz is shown in \autoref{code:fb1}--it shows the definition of a function \pcode{def}, followed by name and arguments, and its implementation that follows the \pcode{=} sign. The loop (\pcode{for}) and condition (\pcode{if}, \pcode{else}) keywords are the old friends from other languages. 

\begin{lstlisting}[caption={Fizz Buzz}, label={code:fb1}, language=Scala, escapechar=|]
def fizzBuzz = {
  for (i <- 1 to 100) {
    if (i % 15 == 0) println("FizzBuzz")
    else if (i % 3 == 0) println("Fizz")
    else if (i % 5 == 0) println("Buzz")
    else println(i)
  }
}
\end{lstlisting}

The FizzBuzz from \autoref{code:fb1} isn't particularly re-usable: it simply prints 100 elements to the standard output, nothing else and nothing more. There is no way, for example, to direct the output to a web socket, or to use it to determine how it maps of the value in the \pcode{integer} domain to the ``FizzBuzz domain''. Hmm!--\emph{mapping} and \emph{domain} sound like mathematics; and functional programming is supposed to be somehow more mathematical. And mathematics is jolly wonderful. 

The first step in making the \pcode{fizzBuzz} more mathematical is to make it map an input to exactly one useful output. Right now, its return type now is \pcode{Unit}, which is a bit like \pcode{void} in Java and C; changing its definition to \pcode{def fizzBuzz2(max: Int): Unit} (and then using the \pcode{max} parameter in the loop) isn't particularly useful: it is a mapping from a number to \pcode{Unit}. And, if this were mathematics, there can be only one such mapping: \pcode{def fizzBuzz2(max: Int): Unit = ()}. Instead of printing the elements to the console, the implementation needs to return a value that can be printed. A a simple \pcode{String} would do, but a \pcode{Seq} of \pcode{String}s is better. The type becomes \pcode{Int => Seq[String]}, and the implementation is shown in \autoref{code:fb2}.

\begin{lstlisting}[caption={Fizz Buzz}, label={code:fb2}, language=Scala, escapechar=|]
def fizzBuzz(max: Int): Seq[String] = {
  var result = List.empty[String]
  for (i <- 1 to max) {
    if (i % 15 == 0) result = result :+ "FizzBuzz"
    else if (i % 3 == 0) result = result :+ "Fizz"
    else if (i % 5 == 0) result = result :+ "Buzz"
    else result = result :+ i.toString
  }
  result
}
\end{lstlisting}

This is a huge improvement! The \pcode{fizzBuzz} is now indeed a function: it maps input to output and its result depends only on the value of the parameter. It would even be possible to pre-compute the result for all possible values of the input and replace the function's body with a look-up in that table: the function would become just data! 

Well, the outside looks great, but the implementation stinks! It uses mutation, and what about the strange \pcode{:+} operator in \pcode{result :+ "Fizz"}, never mind the \pcode{for (i <- 1 to max) \{...\}} nonsense!

\begin{lstlisting}[caption={Fizz Buzz}, label={code:fb3}, language=Scala, escapechar=|]
def fizzBuzz(max: Int): Seq[String] = {
  def fb(i: Int): String =
    if (i % 15 == 0) "FizzBuzz"
    else if (i % 3 == 0) "Fizz"
    else if (i % 5 == 0) "Buzz"
    else i.toString

  (1 to max).map(fb)
}
\end{lstlisting}




In Scala, every concrete type (except \pcode{Nothing}) can have a value: for example, the type \pcode{Boolean} is inhabited by values \pcode{true, false}; the type \pcode{Int} is inhabited by values such as \pcode{5, 42, -100, 0, ...}; the type \pcode{String} is inhabited by values such as \pcode{"Hi", ":)", ""}; the type \pcode{Unit} is inhabited by the only value \pcode{()}. (No, really, it's perfectly good Scala syntax to write \pcode{()} as value. It's just not particularly useful.) The only type that does not have any inhabitants is \pcode{Nothing}: it represents expressions that \emph{diverge}, for example throwing an exception.

Taking a more precise look at \pcode{def fizzBuzz} reveals its type to be \pcode{Unit}; it evaluates to only one value, namely \pcode{()}. If it were a function in the sense of strictly mapping input to output, it would be no different from any other \pcode{()} \emph{constant}. But \pcode{fizzBuzz} does some additional work before returning \pcode{()}; this additional work is not represented by its type, even though it is its \emph{raison d'être}. 

In Java and C, there is no \emph{value} of type \pcode{void}

 As it stands, its type is \pcode{() => Unit}, 

\newpage

\section{Pattern matching}
sasd
\newpage

\section{}

\printbibliography

\end{document}
