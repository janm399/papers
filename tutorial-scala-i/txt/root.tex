\documentclass[10 pt]{article}
\input{../../common.tex}

\usepackage[OT1]{fontenc}
\usepackage{marvosym}
\newcommand*\eiadfamily{\fontencoding{OT1}\fontfamily{eiad}\selectfont}

\addbibresource{root.bib}

\title{Scala Tutorial I}

\author{Jan Macháček}

\begin{document}

\maketitle
\begin{abstract}
  Scala is a fusion langauge that combines functional and object-oriented programming paradigms in a syntax that is similar to most other \emph{C-like} languages. The ...
\end{abstract}
\bigskip

\section{Syntax crash-course}
Scala's syntax follows the syntax of other C-like languages, though--like Pascal--the type specification follows an identifier. Scala's \pcode{class} behaves exactly like Java's \pcode{class}, and its synax is not wildly different. (See \autoref{code:syntax-class}.)

\begin{lstlisting}[caption={Classes and methods}, label={code:syntax-class}, language=Scala, escapechar=|]
|Class declaration means the same thing as Java; constructor parameters are specified in the block immediately following the class name.|
|Note that the types follow the identifier; instead of |String constructorParam1| Scala uses |constructorParam1: String
class MyClass(constructorParam1: String, constuctorParam2: Int) {
  
  |Methods begin with the keyword |def|, followed by name and parameters. The return type follows similar pattern; |Unit| means |void.
  |The body of the method follows the equals sign.|
  def execute(methodParam1: List[Int]): Unit = {

  }

}

|Constructing instances uses the typical |new| keyword...|
new MyClass("foo", 42)
  |Method invocation is exactly like Java's|
  .execute(List(1, 2, 3))
\end{lstlisting}

Most of this syntax is familiar and unsurprising; the only thing that might feel odd is the square bracket for ``generics'' in \pcode{List[Int]}: in Java, this would be written as \pcode{List<Int>}. This is part of Scala's legacy. A long, long time ago, XML was very exciting; and Scala allows XML literals. These XML literals use the angle brackets. This meant that a different symbol had to be used for type parameters. Because the square bracket is used for type parameters, array indexing is also done using regular parentheses\footnote{I know, it looks like VisualBasic or Fortran (formerly FORTRAN)!}.

Interfaces use the \pcode{trait} keyword in Scala; their usage and features are similar to \pcode{interface} in Java (particularly Java 8 which adds default implementations). It is possible to make anonymous implementations of a \pcode{trait}, as well as to implement it in ordinary \pcode{class}es. (Viz \autoref{code:syntax-trait}.)

\begin{lstlisting}[caption={Traits}, label={code:syntax-trait}, language=Scala, escapechar=|]
|Apart from the |trait| keyword, the syntax is unremarkable|
trait ReportGenerator {
  |Interface methods are public and abstract; they specify parameters and return type|
  def generate(userId: Int): Array[Byte]
}

|A |trait| can be implemented in a |class| using the keyword |extends|. Additional traits to be implemented use the |with| keyword.|
class ReportGeneratorImpl extends ReportGenerator with Cloneable {
  |Instead of the |@Override| annotation Scala uses the |override| keyword.|
  override def generate(userId: Int): Array[Byte] = ...
  override def clone(): AnyRef = ...
}

|It is also possible to make an anonymous implementation of a trait using the |new| keyword.|
new ReportGenerator {
  override def generate(userId: Int): Array[Byte] = ...
}
\end{lstlisting}

It is worth noting that there is no special syntax for \emph{array of X} in Scala. Instead, it uses \pcode{Array} with the specified type parameter. (So, Java's \pcode{byte[]} becomes \pcode{Array[Byte]}, \pcode{User[]} becomes \pcode{Array[User]}, and so on.) Also notice the \pcode{AnyRef} in the implementation of the \pcode{clone()} method--it is equivalent to \pcode{java.lang.Object}.

So far, there are no major surprises: classes and interfaces work just like most other languages, constructor, method, and parameter definition also looks fairly ordinary. The syntax for functions (finally!) uses parameters (each with its type following the \pcode{:} symbol, if needed) followed by fat arrow \pcode{=>}, and the body of the function. Usage is the same as Java 8; and Scala's collections library contains concepts that are fairly similar.

\begin{lstlisting}[caption={Fields \& variables}, label={code:syntax-fun}, language=Scala, escapechar=|]
|Double every |Int| in the list|
List(1, 2, 3, ...).map { (x: Int) => 2 * x }

|Scala can infer the type of |x|, so there's no need to specify it|
List(1, 2, 3, ...).map { x => 2 * x }

|An alternative syntax uses paretheses in place of brackets|
List(1, 2, 3, ...).map(x => 2 * x)

|It is possible to avoid having to declare the parameter |x|, and use |_| instead. Scala compiler replaces the every occurrence of |_| with a fresh parameter declaration.|
List(1, 2, 3, ...).map(2 * _)
\end{lstlisting}

Finally, fields (and variables) use the keywords \pcode{val} and \pcode{var}. The first declares an immutable variable (and a getter if field), the second declares a mutable variable (and a getter and setter if field); see \autoref{code:syntax-fv}.

\begin{lstlisting}[caption={Fields \& variables}, label={code:syntax-fv}, language=Scala, escapechar=|]
|Field definitions have to specify initial value; use |_| for default value.|
class User {
  var id: Long = _
  var name: String = _
  var dob: Date = _
}

val user = new User
\end{lstlisting}

This code is terrible! The default value for reference types (\pcode{AnyRef}s) is \pcode{null}, and variants of \emph{zero} for primitive types. The \pcode{name} and \pcode{dob} fields in the \pcode{user} instance are \pcode{null}, and \pcode{id} is \pcode{0L}. What's worse, the class has setters for these fields, and it's possible to invoke them. The syntax is somewhat nicer--it looks like plain assignment using the \pcode{=} operator, though it is actually invoking a setter--but the semantics of the code in \autoref{code:syntax-fv2} is terrible.

\begin{lstlisting}[caption={Fields \& variables II}, label={code:syntax-fv2}, language=Scala, escapechar=|]
|Field definitions have to specify initial value; use |_| for default value.|
class User {
  var id: Long = _
  var name: String = _
  var dob: Date = _
}

val user = new User
user.id = 5
user.name = "Foo Quux"
user.dob = ...
\end{lstlisting}

While syntactically valid code, it is very confusing. The \pcode{user} variable is declared immutable, yet it is possible to invoke its setters. The equivalent Java code would declare the \pcode{user} variable \pcode{final}, but then still use the setters to mutate it.

\subsection{Killer features}
The syntax (and its application) so far looks just like Java with less typing. There must be something else that makes it worth leaving the creature comforts of Java. 

\begin{itemize}
  \item case classes
  \item pattern matching
  \item everything is an expression
  \item for comprehensions
  \item implicits
  \item rich type system
\end{itemize}

\paragraph{case classes} A case class is just like a class in that it is a container for data and methods, but the fields it contains only have getters. (Immutability only goes as far as immutability of the references. Even in Scala, immutability without any additional code is equivalent to using \pcode{final} in Java.) Nevertheless, case classes are fantastically convenient to define data structures. Consider the \pcode{Person} case class defined in \autoref{code:cc1}.

\begin{lstlisting}[caption={Case class \pcode{Person}}, label={code:cc1}, language=Scala, escapechar=|]
case class Person(firstName: String, lastName: String, age: Int)
\end{lstlisting}

This is all it takes to define an immutable structure (with the T\&Cs from above) with the fields \pcode{firstName}, \pcode{lastName}, and \pcode{age}; but also with appropriate \pcode{toString}, \pcode{hashCode}, and \pcode{equals} implementations. These automatically generated implementations delegate to the \pcode{toString}, \pcode{hashCode}, and \pcode{equals} methods of all the fields, in the order in which they are specified.

To create an instance of a case class, do not use the \pcode{new} keyword; instead, write the parameters directly after the case class name, as shown in \autoref{code:cc2}.

\begin{lstlisting}[caption={Using case class \pcode{Person}}, label={code:cc2}, language=Scala, escapechar=|]
|Notice that there is no |new| keyword; the parameter values are applied directly after the case class name.|
val fq = Person("Foo", "Quux", 42)

|To access the fields, use the familiar |.| notation.|
fq.firstName | $\rvert$ |"Foo"

|Invoking the |toString| method prints a reasonable representation of the case class.|
fq.toString | $\rvert$ |"Person(Foo,Quux,42)"

|It is possible to vary the order of the parameters if the parameter names are also specified. This can help readability.|
val fb = Person(lastName = "Baz", firstName = "Foo", age = 50)
fb.toString | $\rvert$ |"Person(Foo,Baz,50)"

|Equality is implemented by delegation to the parameters' |hashCode| and |equals| methods.|
Person("Foo", "Quux", 42) == fq  | $\rvert$ |true|, even though they are \emph{different} instances.|
fq == Person("Foo", "Quux", 42)  | $\rvert$ |true|, even though they are \emph{different} instances.|
\end{lstlisting}

The consciseness of Scala's syntax is beginning to show. It would have been much more cumbersome to implement all this (including correct \pcode{hashCode}, \pcode{equals}, and reasonable \pcode{toString}) in Java. Even with correct implementations, it would not have been possible to use \pcode{==} to test for instance equality. 

\begin{example}[Try this out: Using case classes and functions]
In \pcode{src/scala}, run \pcode{sbt console}; in the console, define a \pcode{case class} for an employee record (decide which fields would be useful); then define a \pcode{case class} for employment linking an \pcode{employee} and his or her \pcode{salary}. Then use \pcode{List.fill(N)(Employment(...))} and useful methods in \pcode{scala.util.Random} to generate $N$ random \pcode{Employment} instances. Assign those to a variable.

\begin{itemize}
  \item find the top fat cat in the list. (Hint: use \pcode{map}, \pcode{max}, and \pcode{find} functions on the \pcode{List[Employment]} to find the fattest cat.)
  \item find the top 10 fat cats in the list. (Hint: use \pcode{sortBy} or \pcode{sortWith}, followed by \pcode{take})
\end{itemize}
\end{example}

\section{Spring Framework}
The Spring Framework is a dependency injection framework; it encourages composition over inheritance, it encourages expressing dependencies as interfaces rather than concrete implementations. The framework takes care of instantiating the components in the correct order; most components (the ones that fall into the \pcode{@Component} sterotype) are \emph{singletons}. This means that it is possible to treat the \pcode{@Component}-annotated components as namespaces rather than containers of state\footnote{In fact if the methods in \pcode{@Component}-annotated classes mutates \& accesses its fields, it will suffer from race conditions.}. The reason why Spring Framework encourages programming to interfaces is to make the software easily testable: there can be separate implementations or mocks for unit and integration tests.

\begin{lstlisting}[caption={Components}, label={code:sf1-java}, language=Java, escapechar=|]
interface ReportGenerator {
    |Generates the PDF report for the given $user$,|
    |returns the byte array representing the PDF contents|
    byte[] generate(final String user);
}

@Component
public class ReportService {
    private final ReportGenerator reportGenerator;

    @Inject
    public ReportService(final ReportGenerator reportGenerator) {
        this.reportGenerator = reportGenerator;
    }

    public void reportAll() {
        for (final String user : Arrays.asList("a", "b", "c")) {
            final byte[] pdf = this.reportGenerator.generate(user);
            |Now you're on your own...|
        }
    }
 }
\end{lstlisting}

For a Spring Framework application to be able to construct the \pcode{ReportService}, it needs to be able to construct exactly one component that implements the \pcode{ReportGenerator} interface.

\begin{lstlisting}[caption={Components}, label={code:sf2-java}, language=Java, escapechar=|]
@Component
public class JasperReportsReportGenerator implements ReportGenerator {
    public byte[] generate(final String user) {
        ...
    }
}
\end{lstlisting}

Without a DI framework, the work of constructing the dependencies would fall on the programmers, yielding code similar to \autoref{code:sf3-java}.

\begin{lstlisting}[caption={Manual DI}, label={code:sf3-java}, language=Java, escapechar=|]
|Typically in |public static void main(String[] args) |or in a test:|

ReportGenerator rg = new JasperReportsReportGenerator();
ReportService rs = new ReportService(rg);
\end{lstlisting}

Constructing the instances of the \pcode{JasperReportsReportGenerator} and \pcode{ReportService} using their constructors isn't a problem per se, but with growing number of dependencies this grows to be tedious.


\section{Zero to hundred}
FizzBuzz is a typical program that follows \emph{Hello, world}, adding iteration and conditions. The Scala version of FizzBuzz is shown in \autoref{code:fb1}--it shows the definition of a function \pcode{def}, followed by name and arguments, and its implementation that follows the \pcode{=} sign. The loop (\pcode{for}) and condition (\pcode{if}, \pcode{else}) keywords are the old friends from other languages. 

\begin{lstlisting}[caption={Fizz Buzz}, label={code:fb1}, language=Scala, escapechar=|]
def fizzBuzz = {
  for (i <- 1 to 100) {
    if (i % 15 == 0) println("FizzBuzz")
    else if (i % 3 == 0) println("Fizz")
    else if (i % 5 == 0) println("Buzz")
    else println(i)
  }
}
\end{lstlisting}

The FizzBuzz from \autoref{code:fb1} isn't particularly re-usable: it simply prints 100 elements to the standard output, nothing else and nothing more. There is no way, for example, to direct the output to a web socket, or to use it to determine how it maps of the value in the \pcode{integer} domain to the ``FizzBuzz domain''. Hmm!--\emph{mapping} and \emph{domain} sound like mathematics; and functional programming is supposed to be somehow more mathematical. And mathematics is jolly wonderful. 

The first step in making the \pcode{fizzBuzz} more mathematical is to make it map an input to exactly one useful output. Right now, its return type now is \pcode{Unit}, which is a bit like \pcode{void} in Java and C; changing its definition to \pcode{def fizzBuzz2(max: Int): Unit} (and then using the \pcode{max} parameter in the loop) isn't particularly useful: it is a mapping from a number to \pcode{Unit}. And, if this were mathematics, there can be only one such mapping: \pcode{def fizzBuzz2(max: Int): Unit = ()}. Instead of printing the elements to the console, the implementation needs to return a value that can be printed. A a simple \pcode{String} would do, but a \pcode{Seq} of \pcode{String}s is better. The type becomes \pcode{Int => Seq[String]}, and the implementation is shown in \autoref{code:fb2}.

\begin{lstlisting}[caption={Fizz Buzz}, label={code:fb2}, language=Scala, escapechar=|]
def fizzBuzz(max: Int): Seq[String] = {
  var result = List.empty[String]
  for (i <- 1 to max) {
    if (i % 15 == 0) result = result :+ "FizzBuzz"
    else if (i % 3 == 0) result = result :+ "Fizz"
    else if (i % 5 == 0) result = result :+ "Buzz"
    else result = result :+ i.toString
  }
  result
}
\end{lstlisting}

This is a huge improvement! The \pcode{fizzBuzz} is now indeed a function: it maps input to output and its result depends only on the value of the parameter. It would even be possible to pre-compute the result for all possible values of the input and replace the function's body with a look-up in that table: the function would become just data! 

Well, the outside looks great, but the implementation stinks! It uses mutation, and what about the strange \pcode{:+} operator in \pcode{result :+ "Fizz"}, never mind the \pcode{for (i <- 1 to max) \{...\}} nonsense!

\begin{lstlisting}[caption={Fizz Buzz}, label={code:fb3}, language=Scala, escapechar=|]
def fizzBuzz(max: Int): Seq[String] = {
  def fb(i: Int): String =
    if (i % 15 == 0) "FizzBuzz"
    else if (i % 3 == 0) "Fizz"
    else if (i % 5 == 0) "Buzz"
    else i.toString

  (1 to max).map(fb)
}
\end{lstlisting}




In Scala, every concrete type (except \pcode{Nothing}) can have a value: for example, the type \pcode{Boolean} is inhabited by values \pcode{true, false}; the type \pcode{Int} is inhabited by values such as \pcode{5, 42, -100, 0, ...}; the type \pcode{String} is inhabited by values such as \pcode{"Hi", ":)", ""}; the type \pcode{Unit} is inhabited by the only value \pcode{()}. (No, really, it's perfectly good Scala syntax to write \pcode{()} as value. It's just not particularly useful.) The only type that does not have any inhabitants is \pcode{Nothing}: it represents expressions that \emph{diverge}, for example throwing an exception.

Taking a more precise look at \pcode{def fizzBuzz} reveals its type to be \pcode{Unit}; it evaluates to only one value, namely \pcode{()}. If it were a function in the sense of strictly mapping input to output, it would be no different from any other \pcode{()} \emph{constant}. But \pcode{fizzBuzz} does some additional work before returning \pcode{()}; this additional work is not represented by its type, even though it is its \emph{raison d'être}. 

In Java and C, there is no \emph{value} of type \pcode{void}

 As it stands, its type is \pcode{() => Unit}, 

\newpage

\section{Pattern matching}
sasd
\newpage

\section{}

\printbibliography

\end{document}
